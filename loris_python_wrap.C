/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 1.3.20
 * 
 * This file is not intended to be easily readable and contains a number of 
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG 
 * interface file instead. 
 * ----------------------------------------------------------------------------- */

#define SWIGPYTHON

#ifdef __cplusplus
template<class T> class SwigValueWrapper {
    T *tt;
public:
    SwigValueWrapper() : tt(0) { }
    SwigValueWrapper(const SwigValueWrapper<T>& rhs) : tt(new T(*rhs.tt)) { }
    SwigValueWrapper(const T& t) : tt(new T(t)) { }
    ~SwigValueWrapper() { delete tt; } 
    SwigValueWrapper& operator=(const T& t) { delete tt; tt = new T(t); return *this; }
    operator T&() const { return *tt; }
    T *operator&() { return tt; }
private:
    SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
};                                                    
#endif


#include "Python.h"

/*************************************************************** -*- c -*-
 * python/precommon.swg
 *
 * Rename all exported symbols from common.swg, to avoid symbol
 * clashes if multiple interpreters are included
 *
 ************************************************************************/

#define SWIG_TypeRegister    SWIG_Python_TypeRegister
#define SWIG_TypeCheck       SWIG_Python_TypeCheck
#define SWIG_TypeCast        SWIG_Python_TypeCast
#define SWIG_TypeDynamicCast SWIG_Python_TypeDynamicCast
#define SWIG_TypeName        SWIG_Python_TypeName
#define SWIG_TypeQuery       SWIG_Python_TypeQuery
#define SWIG_TypeClientData  SWIG_Python_TypeClientData
#define SWIG_PackData        SWIG_Python_PackData 
#define SWIG_UnpackData      SWIG_Python_UnpackData 


/***********************************************************************
 * common.swg
 *
 *     This file contains generic SWIG runtime support for pointer
 *     type checking as well as a few commonly used macros to control
 *     external linkage.
 *
 * Author : David Beazley (beazley@cs.uchicago.edu)
 *
 * Copyright (c) 1999-2000, The University of Chicago
 * 
 * This file may be freely redistributed without license or fee provided
 * this copyright message remains intact.
 ************************************************************************/

#include <string.h>

#if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#  if defined(_MSC_VER) || defined(__GNUC__)
#    if defined(STATIC_LINKED)
#      define SWIGEXPORT(a) a
#      define SWIGIMPORT(a) extern a
#    else
#      define SWIGEXPORT(a) __declspec(dllexport) a
#      define SWIGIMPORT(a) extern a
#    endif
#  else
#    if defined(__BORLANDC__)
#      define SWIGEXPORT(a) a _export
#      define SWIGIMPORT(a) a _export
#    else
#      define SWIGEXPORT(a) a
#      define SWIGIMPORT(a) a
#    endif
#  endif
#else
#  define SWIGEXPORT(a) a
#  define SWIGIMPORT(a) a
#endif

#ifdef SWIG_GLOBAL
#  define SWIGRUNTIME(a) SWIGEXPORT(a)
#else
#  define SWIGRUNTIME(a) static a
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef void *(*swig_converter_func)(void *);
typedef struct swig_type_info *(*swig_dycast_func)(void **);

typedef struct swig_type_info {
  const char             *name;
  swig_converter_func     converter;
  const char             *str;
  void                   *clientdata;
  swig_dycast_func        dcast;
  struct swig_type_info  *next;
  struct swig_type_info  *prev;
} swig_type_info;

#ifdef SWIG_NOINCLUDE

SWIGIMPORT(swig_type_info *) SWIG_TypeRegister(swig_type_info *);
SWIGIMPORT(swig_type_info *) SWIG_TypeCheck(char *c, swig_type_info *);
SWIGIMPORT(void *)           SWIG_TypeCast(swig_type_info *, void *);
SWIGIMPORT(swig_type_info *) SWIG_TypeDynamicCast(swig_type_info *, void **);
SWIGIMPORT(const char *)     SWIG_TypeName(const swig_type_info *);
SWIGIMPORT(swig_type_info *) SWIG_TypeQuery(const char *);
SWIGIMPORT(void)             SWIG_TypeClientData(swig_type_info *, void *);
SWIGIMPORT(char *)           SWIG_PackData(char *, void *, int);
SWIGIMPORT(char *)           SWIG_UnpackData(char *, void *, int);

#else

static swig_type_info *swig_type_list = 0;

/* Register a type mapping with the type-checking */
SWIGRUNTIME(swig_type_info *)
SWIG_TypeRegister(swig_type_info *ti) {
  swig_type_info *tc, *head, *ret, *next;
  /* Check to see if this type has already been registered */
  tc = swig_type_list;
  while (tc) {
    if (strcmp(tc->name, ti->name) == 0) {
      /* Already exists in the table.  Just add additional types to the list */
      if (tc->clientdata) ti->clientdata = tc->clientdata;
      head = tc;
      next = tc->next;
      goto l1;
    }
    tc = tc->prev;
  }
  head = ti;
  next = 0;

  /* Place in list */
  ti->prev = swig_type_list;
  swig_type_list = ti;

  /* Build linked lists */
  l1:
  ret = head;
  tc = ti + 1;
  /* Patch up the rest of the links */
  while (tc->name) {
    head->next = tc;
    tc->prev = head;
    head = tc;
    tc++;
  }
  if (next) next->prev = head;
  head->next = next;
  return ret;
}

/* Check the typename */
SWIGRUNTIME(swig_type_info *) 
SWIG_TypeCheck(char *c, swig_type_info *ty) {
  swig_type_info *s;
  if (!ty) return 0;        /* Void pointer */
  s = ty->next;             /* First element always just a name */
  do {
    if (strcmp(s->name,c) == 0) {
      if (s == ty->next) return s;
      /* Move s to the top of the linked list */
      s->prev->next = s->next;
      if (s->next) {
        s->next->prev = s->prev;
      }
      /* Insert s as second element in the list */
      s->next = ty->next;
      if (ty->next) ty->next->prev = s;
      ty->next = s;
      s->prev = ty;
      return s;
    }
    s = s->next;
  } while (s && (s != ty->next));
  return 0;
}

/* Cast a pointer up an inheritance hierarchy */
SWIGRUNTIME(void *) 
SWIG_TypeCast(swig_type_info *ty, void *ptr) {
  if ((!ty) || (!ty->converter)) return ptr;
  return (*ty->converter)(ptr);
}

/* Dynamic pointer casting. Down an inheritance hierarchy */
SWIGRUNTIME(swig_type_info *) 
SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
  swig_type_info *lastty = ty;
  if (!ty || !ty->dcast) return ty;
  while (ty && (ty->dcast)) {
    ty = (*ty->dcast)(ptr);
    if (ty) lastty = ty;
  }
  return lastty;
}

/* Return the name associated with this type */
SWIGRUNTIME(const char *)
SWIG_TypeName(const swig_type_info *ty) {
  return ty->name;
}

/* Search for a swig_type_info structure */
SWIGRUNTIME(swig_type_info *)
SWIG_TypeQuery(const char *name) {
  swig_type_info *ty = swig_type_list;
  while (ty) {
    if (ty->str && (strcmp(name,ty->str) == 0)) return ty;
    if (ty->name && (strcmp(name,ty->name) == 0)) return ty;
    ty = ty->prev;
  }
  return 0;
}

/* Set the clientdata field for a type */
SWIGRUNTIME(void)
SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
  swig_type_info *tc, *equiv;
  if (ti->clientdata == clientdata) return;
  ti->clientdata = clientdata;
  equiv = ti->next;
  while (equiv) {
    if (!equiv->converter) {
      tc = swig_type_list;
      while (tc) {
        if ((strcmp(tc->name, equiv->name) == 0))
          SWIG_TypeClientData(tc,clientdata);
        tc = tc->prev;
      }
    }
    equiv = equiv->next;
  }
}

/* Pack binary data into a string */
SWIGRUNTIME(char *)
SWIG_PackData(char *c, void *ptr, int sz) {
  static char hex[17] = "0123456789abcdef";
  int i;
  unsigned char *u = (unsigned char *) ptr;
  register unsigned char uu;
  for (i = 0; i < sz; i++,u++) {
    uu = *u;
    *(c++) = hex[(uu & 0xf0) >> 4];
    *(c++) = hex[uu & 0xf];
  }
  return c;
}

/* Unpack binary data from a string */
SWIGRUNTIME(char *)
SWIG_UnpackData(char *c, void *ptr, int sz) {
  register unsigned char uu = 0;
  register int d;
  unsigned char *u = (unsigned char *) ptr;
  int i;
  for (i = 0; i < sz; i++, u++) {
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu = ((d - '0') << 4);
    else if ((d >= 'a') && (d <= 'f'))
      uu = ((d - ('a'-10)) << 4);
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu |= (d - '0');
    else if ((d >= 'a') && (d <= 'f'))
      uu |= (d - ('a'-10));
    *u = uu;
  }
  return c;
}

#endif

#ifdef __cplusplus
}
#endif

/***********************************************************************
 * python.swg
 *
 *     This file contains the runtime support for Python modules
 *     and includes code for managing global variables and pointer
 *     type checking.
 *
 * Author : David Beazley (beazley@cs.uchicago.edu)
 ************************************************************************/

#include "Python.h"

#ifdef __cplusplus
extern "C" {
#endif

#define SWIG_PY_INT     1
#define SWIG_PY_FLOAT   2
#define SWIG_PY_STRING  3
#define SWIG_PY_POINTER 4
#define SWIG_PY_BINARY  5

/* Flags for pointer conversion */

#define SWIG_POINTER_EXCEPTION     0x1
#define SWIG_POINTER_DISOWN        0x2

/* Exception handling in wrappers */
#define SWIG_fail   goto fail

/* Constant information structure */
typedef struct swig_const_info {
    int type;
    char *name;
    long lvalue;
    double dvalue;
    void   *pvalue;
    swig_type_info **ptype;
} swig_const_info;

/* Common SWIG API */
#define SWIG_ConvertPtr(obj, pp, type, flags) \
  SWIG_Python_ConvertPtr(obj, pp, type, flags)
#define SWIG_NewPointerObj(p, type, flags) \
  SWIG_Python_NewPointerObj(p, type, flags)
#define SWIG_MustGetPtr(p, type, argnum, flags) \
  SWIG_Python_MustGetPtr(p, type, argnum, flags)

/* Python-specific SWIG API */
#define SWIG_newvarlink() \
  SWIG_Python_newvarlink()
#define SWIG_addvarlink(p, name, get_attr, set_attr) \
  SWIG_Python_addvarlink(p, name, get_attr, set_attr)
#define SWIG_ConvertPacked(obj, ptr, sz, ty, flags) \
  SWIG_Python_ConvertPacked(obj, ptr, sz, ty, flags)
#define SWIG_NewPackedObj(ptr, sz, type) \
  SWIG_Python_NewPackedObj(ptr, sz, type)
#define SWIG_InstallConstants(d, constants) \
  SWIG_Python_InstallConstants(d, constants)

#ifdef SWIG_NOINCLUDE

SWIGIMPORT(int)               SWIG_Python_ConvertPtr(PyObject *, void **, swig_type_info *, int);
SWIGIMPORT(PyObject *)        SWIG_Python_NewPointerObj(void *, swig_type_info *,int own);
SWIGIMPORT(void *)            SWIG_Python_MustGetPtr(PyObject *, swig_type_info *, int, int);
SWIGIMPORT(PyObject *)        SWIG_Python_newvarlink(void);
SWIGIMPORT(void)              SWIG_Python_addvarlink(PyObject *, char *, PyObject *(*)(void), int (*)(PyObject *));
SWIGIMPORT(int)               SWIG_Python_ConvertPacked(PyObject *, void *, int sz, swig_type_info *, int);
SWIGIMPORT(PyObject *)        SWIG_Python_NewPackedObj(void *, int sz, swig_type_info *);
SWIGIMPORT(void)              SWIG_Python_InstallConstants(PyObject *d, swig_const_info constants[]);

#else

/* -----------------------------------------------------------------------------
 * global variable support code.
 * ----------------------------------------------------------------------------- */

typedef struct swig_globalvar {   
  char       *name;                  /* Name of global variable */
  PyObject *(*get_attr)(void);       /* Return the current value */
  int       (*set_attr)(PyObject *); /* Set the value */
  struct swig_globalvar *next;
} swig_globalvar;

typedef struct swig_varlinkobject {
  PyObject_HEAD
  swig_globalvar *vars;
} swig_varlinkobject;

static PyObject *
swig_varlink_repr(swig_varlinkobject *v) {
  v = v;
  return PyString_FromString("<Global variables>");
}

static int
swig_varlink_print(swig_varlinkobject *v, FILE *fp, int flags) {
  swig_globalvar  *var;
  flags = flags;
  fprintf(fp,"Global variables { ");
  for (var = v->vars; var; var=var->next) {
    fprintf(fp,"%s", var->name);
    if (var->next) fprintf(fp,", ");
  }
  fprintf(fp," }\n");
  return 0;
}

static PyObject *
swig_varlink_getattr(swig_varlinkobject *v, char *n) {
  swig_globalvar *var = v->vars;
  while (var) {
    if (strcmp(var->name,n) == 0) {
      return (*var->get_attr)();
    }
    var = var->next;
  }
  PyErr_SetString(PyExc_NameError,"Unknown C global variable");
  return NULL;
}

static int
swig_varlink_setattr(swig_varlinkobject *v, char *n, PyObject *p) {
  swig_globalvar *var = v->vars;
  while (var) {
    if (strcmp(var->name,n) == 0) {
      return (*var->set_attr)(p);
    }
    var = var->next;
  }
  PyErr_SetString(PyExc_NameError,"Unknown C global variable");
  return 1;
}

statichere PyTypeObject varlinktype = {
  PyObject_HEAD_INIT(0)              
  0,
  (char *)"swigvarlink",              /* Type name    */
  sizeof(swig_varlinkobject),         /* Basic size   */
  0,                                  /* Itemsize     */
  0,                                  /* Deallocator  */ 
  (printfunc) swig_varlink_print,     /* Print        */
  (getattrfunc) swig_varlink_getattr, /* get attr     */
  (setattrfunc) swig_varlink_setattr, /* Set attr     */
  0,                                  /* tp_compare   */
  (reprfunc) swig_varlink_repr,       /* tp_repr      */    
  0,                                  /* tp_as_number */
  0,                                  /* tp_as_mapping*/
  0,                                  /* tp_hash      */
};

/* Create a variable linking object for use later */
SWIGRUNTIME(PyObject *)
SWIG_Python_newvarlink(void) {
  swig_varlinkobject *result = 0;
  result = PyMem_NEW(swig_varlinkobject,1);
  varlinktype.ob_type = &PyType_Type;    /* Patch varlinktype into a PyType */
  result->ob_type = &varlinktype;
  result->vars = 0;
  result->ob_refcnt = 0;
  Py_XINCREF((PyObject *) result);
  return ((PyObject*) result);
}

SWIGRUNTIME(void)
SWIG_Python_addvarlink(PyObject *p, char *name, PyObject *(*get_attr)(void), int (*set_attr)(PyObject *p)) {
  swig_varlinkobject *v;
  swig_globalvar *gv;
  v= (swig_varlinkobject *) p;
  gv = (swig_globalvar *) malloc(sizeof(swig_globalvar));
  gv->name = (char *) malloc(strlen(name)+1);
  strcpy(gv->name,name);
  gv->get_attr = get_attr;
  gv->set_attr = set_attr;
  gv->next = v->vars;
  v->vars = gv;
}

/* Convert a pointer value */
SWIGRUNTIME(int)
SWIG_Python_ConvertPtr(PyObject *obj, void **ptr, swig_type_info *ty, int flags) {
  swig_type_info *tc;
  char  *c = 0;
  static PyObject *SWIG_this = 0;
  int    newref = 0;
  PyObject  *pyobj = 0;

  if (!obj) return 0;
  if (obj == Py_None) {
    *ptr = 0;
    return 0;
  }
#ifdef SWIG_COBJECT_TYPES
  if (!(PyCObject_Check(obj))) {
    if (!SWIG_this)
      SWIG_this = PyString_FromString("this");
    pyobj = obj;
    obj = PyObject_GetAttr(obj,SWIG_this);
    newref = 1;
    if (!obj) goto type_error;
    if (!PyCObject_Check(obj)) {
      Py_DECREF(obj);
      goto type_error;
    }
  }  
  *ptr = PyCObject_AsVoidPtr(obj);
  c = (char *) PyCObject_GetDesc(obj);
  if (newref) Py_DECREF(obj);
  goto cobject;
#else
  if (!(PyString_Check(obj))) {
    if (!SWIG_this)
      SWIG_this = PyString_FromString("this");
    pyobj = obj;
    obj = PyObject_GetAttr(obj,SWIG_this);
    newref = 1;
    if (!obj) goto type_error;
    if (!PyString_Check(obj)) {
      Py_DECREF(obj);
      goto type_error;
    }
  } 
  c = PyString_AsString(obj);
  /* Pointer values must start with leading underscore */
  if (*c != '_') {
    *ptr = (void *) 0;
    if (strcmp(c,"NULL") == 0) {
      if (newref) { Py_DECREF(obj); }
      return 0;
    } else {
      if (newref) { Py_DECREF(obj); }
      goto type_error;
    }
  }
  c++;
  c = SWIG_UnpackData(c,ptr,sizeof(void *));
  if (newref) { Py_DECREF(obj); }
#endif

#ifdef SWIG_COBJECT_TYPES
cobject:
#endif

  if (ty) {
    tc = SWIG_TypeCheck(c,ty);
    if (!tc) goto type_error;
    *ptr = SWIG_TypeCast(tc,(void*) *ptr);
  }

  if ((pyobj) && (flags & SWIG_POINTER_DISOWN)) {
    PyObject *zero = PyInt_FromLong(0);
    PyObject_SetAttrString(pyobj,(char*)"thisown",zero);
    Py_DECREF(zero);
  }
  return 0;

type_error:
  if (flags & SWIG_POINTER_EXCEPTION) {
    if (ty && c) {
      char *temp = (char *) malloc(64+strlen(ty->name)+strlen(c));
      sprintf(temp,"Type error. Got %s, expected %s", c, ty->name);
      PyErr_SetString(PyExc_TypeError, temp);
      free((char *) temp);
    } else {
      PyErr_SetString(PyExc_TypeError,"Expected a pointer");
    }
  }
  return -1;
}

/* Convert a pointer value, signal an exception on a type mismatch */
SWIGRUNTIME(void *)
SWIG_Python_MustGetPtr(PyObject *obj, swig_type_info *ty, int argnum, int flags) {
  void *result;
  SWIG_Python_ConvertPtr(obj, &result, ty, flags | SWIG_POINTER_EXCEPTION);
  return result;
}

/* Convert a packed value value */
SWIGRUNTIME(int)
SWIG_Python_ConvertPacked(PyObject *obj, void *ptr, int sz, swig_type_info *ty, int flags) {
  swig_type_info *tc;
  char  *c = 0;

  if ((!obj) || (!PyString_Check(obj))) goto type_error;
  c = PyString_AsString(obj);
  /* Pointer values must start with leading underscore */
  if (*c != '_') goto type_error;
  c++;
  c = SWIG_UnpackData(c,ptr,sz);
  if (ty) {
    tc = SWIG_TypeCheck(c,ty);
    if (!tc) goto type_error;
  }
  return 0;

type_error:

  if (flags) {
    if (ty && c) {
      char *temp = (char *) malloc(64+strlen(ty->name)+strlen(c));
      sprintf(temp,"Type error. Got %s, expected %s", c, ty->name);
      PyErr_SetString(PyExc_TypeError, temp);
      free((char *) temp);
    } else {
      PyErr_SetString(PyExc_TypeError,"Expected a pointer");
    }
  }
  return -1;
}

/* Create a new pointer object */
SWIGRUNTIME(PyObject *)
SWIG_Python_NewPointerObj(void *ptr, swig_type_info *type, int own) {
  PyObject *robj;
  if (!ptr) {
    Py_INCREF(Py_None);
    return Py_None;
  }
#ifdef SWIG_COBJECT_TYPES
  robj = PyCObject_FromVoidPtrAndDesc((void *) ptr, (char *) type->name, NULL);
#else
  {
    char result[1024];
    char *r = result;
    *(r++) = '_';
    r = SWIG_PackData(r,&ptr,sizeof(void *));
    strcpy(r,type->name);
    robj = PyString_FromString(result);
  }
#endif
  if (!robj || (robj == Py_None)) return robj;
  if (type->clientdata) {
    PyObject *inst;
    PyObject *args = Py_BuildValue((char*)"(O)", robj);
    Py_DECREF(robj);
    inst = PyObject_CallObject((PyObject *) type->clientdata, args);
    Py_DECREF(args);
    if (inst) {
      if (own) {
        PyObject *n = PyInt_FromLong(1);
        PyObject_SetAttrString(inst,(char*)"thisown",n);
        Py_DECREF(n);
      }
      robj = inst;
    }
  }
  return robj;
}

SWIGRUNTIME(PyObject *)
SWIG_Python_NewPackedObj(void *ptr, int sz, swig_type_info *type) {
  char result[1024];
  char *r = result;
  if ((2*sz + 1 + strlen(type->name)) > 1000) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,ptr,sz);
  strcpy(r,type->name);
  return PyString_FromString(result);
}

/* Install Constants */
SWIGRUNTIME(void)
SWIG_Python_InstallConstants(PyObject *d, swig_const_info constants[]) {
  int i;
  PyObject *obj;
  for (i = 0; constants[i].type; i++) {
    switch(constants[i].type) {
    case SWIG_PY_INT:
      obj = PyInt_FromLong(constants[i].lvalue);
      break;
    case SWIG_PY_FLOAT:
      obj = PyFloat_FromDouble(constants[i].dvalue);
      break;
    case SWIG_PY_STRING:
      obj = PyString_FromString((char *) constants[i].pvalue);
      break;
    case SWIG_PY_POINTER:
      obj = SWIG_NewPointerObj(constants[i].pvalue, *(constants[i]).ptype,0);
      break;
    case SWIG_PY_BINARY:
      obj = SWIG_NewPackedObj(constants[i].pvalue, constants[i].lvalue, *(constants[i].ptype));
      break;
    default:
      obj = 0;
      break;
    }
    if (obj) {
      PyDict_SetItemString(d,constants[i].name,obj);
      Py_DECREF(obj);
    }
  }
}

#endif

/* Contract support */

#define SWIG_contract_assert(expr, msg) if (!(expr)) { PyErr_SetString(PyExc_RuntimeError, (char *) msg ); goto fail; } else

#ifdef __cplusplus
}
#endif


/* -------- TYPES TABLE (BEGIN) -------- */

#define  SWIGTYPE_p_PartialList swig_types[0] 
#define  SWIGTYPE_p_SpcFile swig_types[1] 
#define  SWIGTYPE_p_Breakpoint swig_types[2] 
#define  SWIGTYPE_p_Analyzer swig_types[3] 
#define  SWIGTYPE_p_double swig_types[4] 
#define  SWIGTYPE_p_Partial swig_types[5] 
#define  SWIGTYPE_p_Loris__Partial swig_types[6] 
#define  SWIGTYPE_p_vectorTdouble_t swig_types[7] 
#define  SWIGTYPE_p_BreakpointEnvelope swig_types[8] 
#define  SWIGTYPE_p_BreakpointPosition swig_types[9] 
#define  SWIGTYPE_p_AiffFile swig_types[10] 
#define  SWIGTYPE_p_SampleVector swig_types[11] 
#define  SWIGTYPE_p_SdifFile swig_types[12] 
#define  SWIGTYPE_p_NewPartialIterator swig_types[13] 
#define  SWIGTYPE_p_NewPlistIterator swig_types[14] 
#define  SWIGTYPE_p_Marker swig_types[15] 
#define  SWIGTYPE_p_PartialListIterator swig_types[16] 
#define  SWIGTYPE_p_PartialIterator swig_types[17] 
static swig_type_info *swig_types[19];

/* -------- TYPES TABLE (END) -------- */


/*-----------------------------------------------
              @(target):= _loris.so
  ------------------------------------------------*/
#define SWIG_init    init_loris

#define SWIG_name    "_loris"
 
/*	exception handling code for procedural interface calls

	Copied from the SWIG manual. Tastes great, less filling.
*/
static char error_message[256];
static int error_status = 0;

void throw_exception(const char *msg) {
        strncpy(error_message,msg,256);
        error_status = 1;
}

void clear_exception() {
        error_status = 0;
}
char *check_exception() {
        if (error_status) return error_message;
        else return NULL;
}

#include <loris.h>

//	import the entire Loris namespace, because
//	SWIG does not seem to like to wrap functions
//	with qualified names (like Loris::channelize),
//	they simply get ignored.
using namespace Loris;

//	notification function for Loris debugging
//	and notifications, installed in initialization
//	block below:
static void printf_notifier( const char * s )
{
	printf("*\t%s\n", s);
}	

//	exception handling for the procedural interface
//	(the pi catches all exceptions and handles them
//	by passing their string descriptions to this 
//	function):
/*static char EXCEPTION_THROWN[256];
static void exception_handler( const char * s )
{
	snprintf(EXCEPTION_THROWN, 255, "%s", s);
}*/


#include <vector>
#include <string>
using std::vector;
using std::string;

// helper function for converting a string to a
// vector of doubles (this will work anywhere)
static bool fill_vector( const string & s, vector<double> & v )
{
	std::string::size_type beg, end;
	const std::string numparts("1234567890+-.");
	beg = s.find_first_of( numparts );
	while ( beg != std::string::npos )
	{
		end = s.find_first_not_of( numparts, beg );
		if ( end == std::string::npos )
			end = s.length();

		double x = atof( s.c_str() + beg );
		v.push_back(x);

		beg = s.find_first_of( numparts, end );
	}
	return true;
}



// helper function for converting a Python sequence
// to a vector of doubles
static bool fill_vector( PyObject * input, vector<double> & v )
{
	// verify that it is a sequence:
	if ( !PySequence_Check(input) )
	{
		PyErr_SetString(PyExc_TypeError,"not a sequence");
		return false;
	}
	// loop over elements of sequence, adding to vector
	int size = PySequence_Length(input);
	for ( int i = 0; i < size; ++i ) 
	{
		PyObject *o = PySequence_GetItem(input,i);
		if (PyNumber_Check(o)) 
		{
			v.push_back( PyFloat_AsDouble(o) );
			Py_DECREF(o);
		}
		else 
		{
			PyErr_SetString(PyExc_TypeError,"sequence must contain numbers");
			Py_DECREF(o);
			return false;
		}
	}	
	
	// return successfully
	return true;
}


#define  SWIG_MemoryError    1
#define  SWIG_IOError        2
#define  SWIG_RuntimeError   3
#define  SWIG_IndexError     4
#define  SWIG_TypeError      5
#define  SWIG_DivisionByZero 6
#define  SWIG_OverflowError  7
#define  SWIG_SyntaxError    8
#define  SWIG_ValueError     9
#define  SWIG_SystemError   10
#define  SWIG_UnknownError  99


static void SWIG_exception_(int code, const char *msg) {
  switch(code) {
  case SWIG_MemoryError:
    PyErr_SetString(PyExc_MemoryError,msg);
    break;
  case SWIG_IOError:
    PyErr_SetString(PyExc_IOError,msg);
    break;
  case SWIG_RuntimeError:
    PyErr_SetString(PyExc_RuntimeError,msg);
    break;
  case SWIG_IndexError:
    PyErr_SetString(PyExc_IndexError,msg);
    break;
  case SWIG_TypeError:
    PyErr_SetString(PyExc_TypeError,msg);
    break;
  case SWIG_DivisionByZero:
    PyErr_SetString(PyExc_ZeroDivisionError,msg);
    break;
  case SWIG_OverflowError:
    PyErr_SetString(PyExc_OverflowError,msg);
    break;
  case SWIG_SyntaxError:
    PyErr_SetString(PyExc_SyntaxError,msg);
    break;
  case SWIG_ValueError:
    PyErr_SetString(PyExc_ValueError,msg);
    break;
  case SWIG_SystemError:
    PyErr_SetString(PyExc_SystemError,msg);
    break;
  default:
    PyErr_SetString(PyExc_RuntimeError,msg);
    break;
  }
}

#define SWIG_exception(a,b) { SWIG_exception_(a,b); SWIG_fail; }


#include <Exception.h>
#include <Notifier.h>
#include <vector>

void dilate_v( PartialList * partials, vector<double> & ivec, vector<double> & tvec )
{
	Loris::debugger << ivec.size() << " initial points, " 
					<< tvec.size() << " target points" << Loris::endl;
					
	if ( ivec.size() != tvec.size() )
	{
		Throw( InvalidArgument, "Invalid arguments to dilate(): there must be as many target points as initial points" );
	}
	
	double * initial = &(ivec[0]);
	double * target = &(tvec[0]);
	int npts = ivec.size();
	dilate( partials, initial, target, npts );
}


	PartialList * importSdif( const char * path )
	{
		PartialList * dst = createPartialList();
		importSdif( path, dst );

		// check for exception:
		if (check_exception())
		{
			destroyPartialList( dst );
			dst = NULL;
		}
		return dst;
	}


	#include<BreakpointEnvelope.h>


	PartialList * importSpc( const char * path )
	{
		PartialList * dst = createPartialList();
		importSpc( path, dst );

		// check for exception:
		if (check_exception())
		{
			destroyPartialList( dst );
			dst = NULL;
		}
		return dst;
	}


	PartialList * morph( const PartialList * src0, const PartialList * src1, 
						 const BreakpointEnvelope * ffreq, 
						 const BreakpointEnvelope * famp, 
						 const BreakpointEnvelope * fbw )
	{
		PartialList * dst = createPartialList();
		morph( src0, src1, ffreq, famp, fbw, dst );
		
		// check for exception:
		if ( check_exception() )
		{
			destroyPartialList( dst );
			dst = NULL;
		}
		return dst;
	}
	PartialList * morph( const PartialList * src0, const PartialList * src1, 
						 double freqweight, 
						 double ampweight, 
						 double bwweight )
	{
		BreakpointEnvelope ffreq( freqweight ), famp( ampweight ), fbw( bwweight );
		
		PartialList * dst = createPartialList();
		morph( src0, src1, &ffreq, &famp, &fbw, dst );
		
		// check for exception:
		if ( check_exception() )
		{
			destroyPartialList( dst );
			dst = NULL;
		}
		return dst;
	}


	SampleVector * synthesize( const PartialList * partials, double srate = 44100.0 )
	{
		SampleVector * dst = createSampleVector(0);
		synthesize( partials, dst, srate );
				
		// check for exception:
		if ( check_exception() )
		{
			destroySampleVector( dst );
			dst = NULL;
		}
		return dst;
	}


	PartialList * copyLabeled( PartialList * partials, long label )
	{
		PartialList * dst = createPartialList();
		copyLabeled( partials, label, dst );
		
		// check for exception:
		if ( check_exception() )
		{
			destroyPartialList( dst );
			dst = NULL;
		}
		return dst;
	}


	PartialList * extractLabeled( PartialList * partials, long label )
	{
		PartialList * dst = createPartialList();
		extractLabeled( partials, label, dst );
		
		// check for exception:
		if ( check_exception() )
		{
			destroyPartialList( dst );
			dst = NULL;
		}
		return dst;
	}

	
	void scaleAmp( PartialList * partials, double w )
	{
		BreakpointEnvelope e( w );
		scaleAmp( partials, &e );
	}
	
	
	void scaleBandwidth( PartialList * partials, double w )
	{
		BreakpointEnvelope e( w );
		scaleBandwidth( partials, &e );
	}
	
	
	void scaleFrequency( PartialList * partials, double w )
	{
		BreakpointEnvelope e( w );
		scaleFrequency( partials, &e );
	}
	
	
	void scaleNoiseRatio( PartialList * partials, double w )
	{
		BreakpointEnvelope e( w );
		scaleNoiseRatio( partials, &e );
	}
	
	
	void shiftPitch( PartialList * partials, double w )
	{
		BreakpointEnvelope e( w );
		shiftPitch( partials, &e );
	}


	const char * version( void )
	{
		static const char * vstr = LORIS_VERSION_STR;
		return vstr;
	}


	#include <Exception.h>
	#include <stdexcept>


	#include<Marker.h>

char const *Marker_name(Marker *self){ return self->name().c_str(); }

	#include<AiffFile.h>

AiffFile *new_AiffFile__SWIG_2(PartialList *l,double sampleRate,double fadeTime){
			return new AiffFile( l->begin(), l->end(), sampleRate, fadeTime );
		}
SampleVector *AiffFile_samples(AiffFile *self){
			SampleVector * vec = new SampleVector( self->samples() );
			return vec;
		}
int AiffFile_channels(AiffFile *self){ return 1; }
void AiffFile_addPartials(AiffFile *self,PartialList *l,double fadeTime){
			self->addPartials( l->begin(), l->end(), fadeTime );
		}
int AiffFile_numMarkers(AiffFile *self){ return self->markers().size(); }
Marker &AiffFile_getMarker(AiffFile *self,int i){
		 	if ( i < 0 || i >= self->markers().size() )
		 	{
		 		Throw( InvalidArgument, "Marker index out of range." );
		 	}
		 	return self->markers()[i];
		 }
void AiffFile_removeMarker(AiffFile *self,int i){
		 	if ( i < 0 || i >= self->markers().size() )
		 	{
		 		Throw( InvalidArgument, "Marker index out of range." );
		 	}
		 	self->markers().erase( self->markers().begin() + i );
		 }
void AiffFile_addMarker(AiffFile *self,Marker m){
		 	self->markers().push_back( m );
		 }

	#include<Analyzer.h>
	#include<Partial.h>

Analyzer *new_Analyzer(double resolutionHz,double windowWidthHz){
			if ( windowWidthHz == 0. )
				windowWidthHz = resolutionHz;
			return new Analyzer( resolutionHz, windowWidthHz );
		}
Analyzer *Analyzer_copy(Analyzer *self){
			return new Analyzer( *self );
		}
PartialList *Analyzer_analyze__SWIG_0(Analyzer *self,SampleVector const *vec,double srate){
			PartialList * partials = new PartialList();
			if ( ! vec->empty() )
				self->analyze( &((*vec)[0]), &((*vec)[vec->size()]), srate );
			partials->splice( partials->end(), self->partials() );
			return partials;
		}
PartialList *Analyzer_analyze__SWIG_1(Analyzer *self,SampleVector const *vec,double srate,BreakpointEnvelope *env){
			PartialList * partials = new PartialList();
			if ( ! vec->empty() )
				self->analyze( *vec, srate, *env );
			partials->splice( partials->end(), self->partials() );
			return partials;
		}

	#include<BreakpointEnvelope.h>

BreakpointEnvelope *BreakpointEnvelope_copy(BreakpointEnvelope *self){
			return new BreakpointEnvelope( *self );
		}

	BreakpointEnvelope *
	BreakpointEnvelopeWithValue( double initialValue )
	{
		return new BreakpointEnvelope( initialValue );
	}

SampleVector *SampleVector_copy(SampleVector *self){
			return new SampleVector( *self );
		}
double SampleVector_getAt(SampleVector *self,unsigned long idx){
			if ( idx >= self->size() )
				throw std::out_of_range("SampleVector::getAt index out of range");
			return (*self)[idx];
		}
void SampleVector_setAt(SampleVector *self,unsigned long idx,double x){
			if ( idx >= self->size() )
				throw std::out_of_range("SampleVector::setAt index out of range");
			(*self)[idx] = x;
		}

	#include<SdifFile.h>

SdifFile *new_SdifFile__SWIG_2(PartialList *l){
			return new SdifFile( l->begin(), l->end() );
		}
PartialList *SdifFile_partials(SdifFile *self){
			PartialList * plist = new PartialList( self->partials() );
			return plist;
		}
void SdifFile_addPartials(SdifFile *self,PartialList *l){
			self->addPartials( l->begin(), l->end() );
		}
int SdifFile_numMarkers(SdifFile *self){ return self->markers().size(); }
Marker &SdifFile_getMarker(SdifFile *self,int i){
		 	if ( i < 0 || i >= self->markers().size() )
		 	{
		 		Throw( InvalidArgument, "Marker index out of range." );
		 	}
		 	return self->markers()[i];
		 }
void SdifFile_removeMarker(SdifFile *self,int i){
		 	if ( i < 0 || i >= self->markers().size() )
		 	{
		 		Throw( InvalidArgument, "Marker index out of range." );
		 	}
		 	self->markers().erase( self->markers().begin() + i );
		 }
void SdifFile_addMarker(SdifFile *self,Marker m){
		 	self->markers().push_back( m );
		 }

	#include<SpcFile.h>

SpcFile *new_SpcFile__SWIG_2(PartialList *l,double midiNoteNum){
			return new SpcFile( l->begin(), l->end(), midiNoteNum );
		}
PartialList *SpcFile_partials(SpcFile *self){
			PartialList * plist = new PartialList( self->partials().begin(), self->partials().end() );
			return plist;
		}
void SpcFile_addPartials(SpcFile *self,PartialList *l){
			self->addPartials( l->begin(), l->end() );
		}
int SpcFile_numMarkers(SpcFile *self){ return self->markers().size(); }
Marker &SpcFile_getMarker(SpcFile *self,int i){
		 	if ( i < 0 || i >= self->markers().size() )
		 	{
		 		Throw( InvalidArgument, "Marker index out of range." );
		 	}
		 	return self->markers()[i];
		 }
void SpcFile_removeMarker(SpcFile *self,int i){
		 	if ( i < 0 || i >= self->markers().size() )
		 	{
		 		Throw( InvalidArgument, "Marker index out of range." );
		 	}
		 	self->markers().erase( self->markers().begin() + i );
		 }
void SpcFile_addMarker(SpcFile *self,Marker m){
		 	self->markers().push_back( m );
		 }

#include<Partial.h>
#include<PartialList.h>
#include<PartialUtils.h>
#include<Notifier.h>
#include <list>

using Loris::debugger;
using Loris::Partial;
using Loris::PartialList;
using Loris::PartialListIterator;
using Loris::Breakpoint;

typedef Loris::Partial::iterator PartialIterator;

/*	new iterator definitions

	These are much better than the old things, more like the 
	iterators in Python 2.2 and later, very much simpler.
	The old iterators will be replaced entirely by the new
	kind soon, very soon.
	
	Note: the only reason I cannot merge the new functionality 
	into the old iterators is that the old iterators use the
	next() method to advance and return another iterator. Duh.
*/
struct NewPlistIterator
{
	PartialList & subject;
	PartialList::iterator it;

	NewPlistIterator( PartialList & l ) : subject( l ), it ( l.begin() ) {}
	NewPlistIterator( PartialList & l, PartialList::iterator i ) : subject( l ), it ( i ) {}
	
	bool atEnd( void ) { return it == subject.end(); }
	bool hasNext( void ) { return !atEnd(); }

	Partial * next( void )
	{
		if ( atEnd() )
		{
			throw_exception("end of PartialList");
			return 0;
		}
		Partial * ret = &(*it);
		++it;
		return ret;
	}
};

typedef Partial::iterator BreakpointPosition;

struct NewPartialIterator
{
	Partial & subject;
	Partial::iterator it;

	NewPartialIterator( Partial & p ) : subject( p ), it ( p.begin() ) {}
	NewPartialIterator( Partial & p, Partial::iterator i ) : subject( p ), it ( i ) {}
	
	bool atEnd( void ) { return it == subject.end(); }
	bool hasNext( void ) { return !atEnd(); }

	BreakpointPosition * next( void )
	{
		if ( atEnd() )
		{
			throw_exception("end of Partial");
			return 0;
		}
		BreakpointPosition * ret = new BreakpointPosition(it);
		++it;
		return ret;
	}
};


Partial *NewPlistIterator_partial(NewPlistIterator *self){
			if ( self->atEnd() )
			{
				throw_exception("end of PartialList");
				return 0;
			}			
			Partial & current = *(self->it);
			return &current;
		}

static PyObject* t_output_helper(PyObject* target, PyObject* o) {
    PyObject*   o2;
    PyObject*   o3;

    if (!target) {                   
        target = o;
    } else if (target == Py_None) {  
        Py_DECREF(Py_None);
        target = o;
    } else {                         
        if (!PyTuple_Check(target)) {
            o2 = target;
            target = PyTuple_New(1);
            PyTuple_SetItem(target, 0, o2);
        }
        o3 = PyTuple_New(1);            
        PyTuple_SetItem(o3, 0, o);      

        o2 = target;
        target = PySequence_Concat(o2, o3); 
        Py_DECREF(o2);                      
        Py_DECREF(o3);
    }
    return target;
}

void PartialList_timeSpan(PartialList *self,double *tmin_out,double *tmax_out){
		 	std::pair<double, double> span = 
		 		Loris::PartialUtils::timeSpan( self->begin(), self->end() );
		 	*tmin_out = span.first;
		 	*tmax_out = span.second;
		 }
NewPlistIterator *PartialList_iterator(PartialList *self){
			return new NewPlistIterator(*self);
		}
NewPlistIterator *PartialList___iter__(PartialList *self){
			return new NewPlistIterator(*self);
		}
void PartialList_append(PartialList *self,Partial *partial){
			self->insert( self->end(), *partial );
		}
NewPlistIterator *PartialList_insert__SWIG_0(PartialList *self,NewPlistIterator *position,Partial *partial){
			if ( self != &(position->subject) )
				return 0;
			return new NewPlistIterator(*self, self->insert( position->it, *partial ) );
		}
void PartialList_erase__SWIG_0(PartialList *self,Partial *partial){
			PartialList::iterator it = self->begin();
			while ( it != self->end() )
			{
				if ( &(*it) == partial )	// compare addresses
				{
					self->erase( it );
					return;
				}
				++it;
			}
			throw_exception( "PartialList.erase(p): p not in PartialList" );
		}
void PartialList_splice__SWIG_0(PartialList *self,PartialList *other){
			self->splice( self->end(), *other );
		}
PartialListIterator PartialList_insert__SWIG_2(PartialList *self,Partial const &partial){
			return self->insert( self->end(), partial );
		}
PartialList *PartialList_copy(PartialList *self){ return new PartialList( *self ); }
NewPartialIterator *Partial_iterator(Partial *self){
			return new NewPartialIterator(*self);
		}
NewPartialIterator *Partial___iter__(Partial *self){
			return new NewPartialIterator(*self);
		}
void Partial_erase__SWIG_0(Partial *self,BreakpointPosition *pos){
			if ( *pos != self->end() )
			{
				*pos = self->erase( *pos );
			}
		}
Partial *Partial_copy(Partial *self){ return new Partial( *self ); }
int Partial_equals(Partial *self,Partial *other){
			return *self == *other;
		}
Breakpoint *Breakpoint_copy(Breakpoint *self){
			return new Breakpoint( *self );
		}
int Breakpoint_equals(Breakpoint *self,Breakpoint *other){
			return *self == *other;
		}
double BreakpointPosition_time(BreakpointPosition *self){ 
			return self->time(); 
		}
Breakpoint *BreakpointPosition_breakpoint(BreakpointPosition *self){ 
			return &(self->breakpoint());
		}
double BreakpointPosition_frequency(BreakpointPosition *self){ return self->breakpoint().frequency(); }
double BreakpointPosition_amplitude(BreakpointPosition *self){ return self->breakpoint().amplitude(); }
double BreakpointPosition_bandwidth(BreakpointPosition *self){ return self->breakpoint().bandwidth(); }
double BreakpointPosition_phase(BreakpointPosition *self){ return self->breakpoint().phase(); }
void BreakpointPosition_setFrequency(BreakpointPosition *self,double x){ self->breakpoint().setFrequency( x ); }
void BreakpointPosition_setAmplitude(BreakpointPosition *self,double x){ self->breakpoint().setAmplitude( x ); }
void BreakpointPosition_setBandwidth(BreakpointPosition *self,double x){ self->breakpoint().setBandwidth( x ); }
void BreakpointPosition_setPhase(BreakpointPosition *self,double x){ self->breakpoint().setPhase( x ); }
Breakpoint *PartialIterator_breakpoint(PartialIterator *self){ 
			return &(self->breakpoint());
		}
PartialIterator *PartialIterator_copy(PartialIterator *self){
			return new PartialIterator( *self );
		}
PartialIterator *PartialIterator_next(PartialIterator *self){
			PartialIterator * next = new PartialIterator(*self);
			++(*next);
			return next;
		}
PartialIterator *PartialIterator_prev(PartialIterator *self){
			PartialIterator * prev = new PartialIterator(*self);
			--(*prev);
			return prev;
		}
int PartialIterator_equals(PartialIterator *self,PartialIterator *other){
			return *self == *other;
		}
int PartialIterator_isInRange(PartialIterator *self,PartialIterator const *begin,PartialIterator const *end){	
		 	PartialIterator it;
		 	for ( it = *begin; it != *end; ++it )
		 	{
		 		if ( it == *self )
		 			return true;
		 	}
		 	return false;
		 }
PartialListIterator *PartialListIterator_copy(PartialListIterator *self){
			return new PartialListIterator( *self );
		}
PartialListIterator *PartialListIterator_next(PartialListIterator *self){
			PartialListIterator * next = new PartialListIterator(*self);
			++(*next);
			return next;
		}
PartialListIterator *PartialListIterator_prev(PartialListIterator *self){
			PartialListIterator * prev = new PartialListIterator(*self);
			--(*prev);
			return prev;
		}
Partial *PartialListIterator_partial(PartialListIterator *self){
			Partial & current = **self;
			return &current;
		}
int PartialListIterator_equals(PartialListIterator *self,PartialListIterator *other){
			return *self == *other;
		}
int PartialListIterator_isInRange(PartialListIterator *self,PartialListIterator const *begin,PartialListIterator const *end){	
		 	PartialListIterator it;
		 	for ( it = *begin; it != *end; ++it )
		 	{
		 		if ( it == *self )
		 			return true;
		 	}
		 	return false;
		 }
#ifdef __cplusplus
extern "C" {
#endif
static PyObject *_wrap_channelize(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    BreakpointEnvelope *arg2 = (BreakpointEnvelope *) 0 ;
    int arg3 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOi:channelize",&obj0,&obj1,&arg3)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_BreakpointEnvelope,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        char * err;
        clear_exception();
        channelize(arg1,arg2,arg3);
        
        if ((err = check_exception()))
        {
            SWIG_exception( SWIG_ValueError, err );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_createFreqReference(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    double arg2 ;
    double arg3 ;
    long arg4 = (long) 0 ;
    BreakpointEnvelope *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Odd|l:createFreqReference",&obj0,&arg2,&arg3,&arg4)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        char * err;
        clear_exception();
        result = (BreakpointEnvelope *)createFreqReference(arg1,arg2,arg3,arg4);
        
        if ((err = check_exception()))
        {
            SWIG_exception( SWIG_ValueError, err );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_BreakpointEnvelope, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_dilate(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    vector<double > *arg2 = 0 ;
    vector<double > *arg3 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOO:dilate",&obj0,&obj1,&obj2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        // test first if input is a string,
        // because a string is a Python sequence,
        // but not a sequence of numbers.
        if (PyString_Check(obj1))
        {
            arg2 = new vector<double>;
            fill_vector( PyString_AsString(obj1), *arg2 );
        }
        else if (PySequence_Check(obj1)) 
        {
            arg2 = new vector<double>;
            if (! fill_vector( obj1, *arg2 ) )
            {
                delete arg2;
                return NULL;
            }
        } 
        else 
        {
            PyErr_SetString(PyExc_TypeError,"could not covert argument to a vector of doubles");
            return NULL;
        }
    }
    {
        // test first if input is a string,
        // because a string is a Python sequence,
        // but not a sequence of numbers.
        if (PyString_Check(obj2))
        {
            arg3 = new vector<double>;
            fill_vector( PyString_AsString(obj2), *arg3 );
        }
        else if (PySequence_Check(obj2)) 
        {
            arg3 = new vector<double>;
            if (! fill_vector( obj2, *arg3 ) )
            {
                delete arg3;
                return NULL;
            }
        } 
        else 
        {
            PyErr_SetString(PyExc_TypeError,"could not covert argument to a vector of doubles");
            return NULL;
        }
    }
    {
        char * err;
        clear_exception();
        try
        {
            dilate_v(arg1,*arg2,*arg3);
            
        }
        catch ( InvalidArgument & ex )
        {
            SWIG_exception(SWIG_ValueError, ex.what() );
        }
        if ((err = check_exception()))
        {
            SWIG_exception( SWIG_ValueError, err );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_distill(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:distill",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        char * err;
        clear_exception();
        distill(arg1);
        
        if ((err = check_exception()))
        {
            SWIG_exception( SWIG_ValueError, err );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_exportAiff(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    char *arg1 ;
    SampleVector *arg2 = (SampleVector *) 0 ;
    double arg3 = (double) 44100.0 ;
    int arg4 = (int) 1 ;
    int arg5 = (int) 16 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"sO|dii:exportAiff",&arg1,&obj1,&arg3,&arg4,&arg5)) goto fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_SampleVector,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        char * err;
        clear_exception();
        exportAiff((char const *)arg1,arg2,arg3,arg4,arg5);
        
        if ((err = check_exception()))
        {
            SWIG_exception( SWIG_ValueError, err );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_exportSdif(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    char *arg1 ;
    PartialList *arg2 = (PartialList *) 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"sO:exportSdif",&arg1,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        char * err;
        clear_exception();
        exportSdif((char const *)arg1,arg2);
        
        if ((err = check_exception()))
        {
            SWIG_exception( SWIG_ValueError, err );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_exportSpc(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    char *arg1 ;
    PartialList *arg2 = (PartialList *) 0 ;
    double arg3 ;
    int arg4 = (int) true ;
    double arg5 = (double) 0. ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"sOd|id:exportSpc",&arg1,&obj1,&arg3,&arg4,&arg5)) goto fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        char * err;
        clear_exception();
        exportSpc((char const *)arg1,arg2,arg3,arg4,arg5);
        
        if ((err = check_exception()))
        {
            SWIG_exception( SWIG_ValueError, err );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_importSdif(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    char *arg1 ;
    PartialList *result;
    
    if(!PyArg_ParseTuple(args,(char *)"s:importSdif",&arg1)) goto fail;
    {
        char * err;
        clear_exception();
        result = (PartialList *)importSdif((char const *)arg1);
        
        if ((err = check_exception()))
        {
            SWIG_exception( SWIG_ValueError, err );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_PartialList, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_importSpc(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    char *arg1 ;
    PartialList *result;
    
    if(!PyArg_ParseTuple(args,(char *)"s:importSpc",&arg1)) goto fail;
    {
        char * err;
        clear_exception();
        result = (PartialList *)importSpc((char const *)arg1);
        
        if ((err = check_exception()))
        {
            SWIG_exception( SWIG_ValueError, err );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_PartialList, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_morph__SWIG_0(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    PartialList *arg2 = (PartialList *) 0 ;
    BreakpointEnvelope *arg3 = (BreakpointEnvelope *) 0 ;
    BreakpointEnvelope *arg4 = (BreakpointEnvelope *) 0 ;
    BreakpointEnvelope *arg5 = (BreakpointEnvelope *) 0 ;
    PartialList *result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    PyObject * obj3 = 0 ;
    PyObject * obj4 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOOOO:morph",&obj0,&obj1,&obj2,&obj3,&obj4)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj2,(void **) &arg3, SWIGTYPE_p_BreakpointEnvelope,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj3,(void **) &arg4, SWIGTYPE_p_BreakpointEnvelope,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj4,(void **) &arg5, SWIGTYPE_p_BreakpointEnvelope,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        char * err;
        clear_exception();
        result = (PartialList *)morph((PartialList const *)arg1,(PartialList const *)arg2,(BreakpointEnvelope const *)arg3,(BreakpointEnvelope const *)arg4,(BreakpointEnvelope const *)arg5);
        
        if ((err = check_exception()))
        {
            SWIG_exception( SWIG_ValueError, err );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_PartialList, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_morph__SWIG_1(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    PartialList *arg2 = (PartialList *) 0 ;
    double arg3 ;
    double arg4 ;
    double arg5 ;
    PartialList *result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOddd:morph",&obj0,&obj1,&arg3,&arg4,&arg5)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        char * err;
        clear_exception();
        result = (PartialList *)morph((PartialList const *)arg1,(PartialList const *)arg2,arg3,arg4,arg5);
        
        if ((err = check_exception()))
        {
            SWIG_exception( SWIG_ValueError, err );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_PartialList, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_morph(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[6];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 5); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if (argc == 5) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_PartialList, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *ptr;
                if (SWIG_ConvertPtr(argv[1], (void **) &ptr, SWIGTYPE_p_PartialList, 0) == -1) {
                    _v = 0;
                    PyErr_Clear();
                } else {
                    _v = 1;
                }
            }
            if (_v) {
                {
                    void *ptr;
                    if (SWIG_ConvertPtr(argv[2], (void **) &ptr, SWIGTYPE_p_BreakpointEnvelope, 0) == -1) {
                        _v = 0;
                        PyErr_Clear();
                    } else {
                        _v = 1;
                    }
                }
                if (_v) {
                    {
                        void *ptr;
                        if (SWIG_ConvertPtr(argv[3], (void **) &ptr, SWIGTYPE_p_BreakpointEnvelope, 0) == -1) {
                            _v = 0;
                            PyErr_Clear();
                        } else {
                            _v = 1;
                        }
                    }
                    if (_v) {
                        {
                            void *ptr;
                            if (SWIG_ConvertPtr(argv[4], (void **) &ptr, SWIGTYPE_p_BreakpointEnvelope, 0) == -1) {
                                _v = 0;
                                PyErr_Clear();
                            } else {
                                _v = 1;
                            }
                        }
                        if (_v) {
                            return _wrap_morph__SWIG_0(self,args);
                        }
                    }
                }
            }
        }
    }
    if (argc == 5) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_PartialList, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *ptr;
                if (SWIG_ConvertPtr(argv[1], (void **) &ptr, SWIGTYPE_p_PartialList, 0) == -1) {
                    _v = 0;
                    PyErr_Clear();
                } else {
                    _v = 1;
                }
            }
            if (_v) {
                {
                    _v = (PyFloat_Check(argv[2]) || PyInt_Check(argv[2]) || PyLong_Check(argv[2])) ? 1 : 0;
                }
                if (_v) {
                    {
                        _v = (PyFloat_Check(argv[3]) || PyInt_Check(argv[3]) || PyLong_Check(argv[3])) ? 1 : 0;
                    }
                    if (_v) {
                        {
                            _v = (PyFloat_Check(argv[4]) || PyInt_Check(argv[4]) || PyLong_Check(argv[4])) ? 1 : 0;
                        }
                        if (_v) {
                            return _wrap_morph__SWIG_1(self,args);
                        }
                    }
                }
            }
        }
    }
    
    PyErr_SetString(PyExc_TypeError,"No matching function for overloaded 'morph'");
    return NULL;
}


static PyObject *_wrap_synthesize(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    double arg2 = (double) 44100.0 ;
    SampleVector *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O|d:synthesize",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        char * err;
        clear_exception();
        result = (SampleVector *)synthesize((PartialList const *)arg1,arg2);
        
        if ((err = check_exception()))
        {
            SWIG_exception( SWIG_ValueError, err );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_SampleVector, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_crop(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    double arg2 ;
    double arg3 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Odd:crop",&obj0,&arg2,&arg3)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        char * err;
        clear_exception();
        crop(arg1,arg2,arg3);
        
        if ((err = check_exception()))
        {
            SWIG_exception( SWIG_ValueError, err );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_copyLabeled(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    long arg2 ;
    PartialList *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Ol:copyLabeled",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        char * err;
        clear_exception();
        result = (PartialList *)copyLabeled(arg1,arg2);
        
        if ((err = check_exception()))
        {
            SWIG_exception( SWIG_ValueError, err );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_PartialList, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_extractLabeled(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    long arg2 ;
    PartialList *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Ol:extractLabeled",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        char * err;
        clear_exception();
        result = (PartialList *)extractLabeled(arg1,arg2);
        
        if ((err = check_exception()))
        {
            SWIG_exception( SWIG_ValueError, err );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_PartialList, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_removeLabeled(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    long arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Ol:removeLabeled",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        char * err;
        clear_exception();
        removeLabeled(arg1,arg2);
        
        if ((err = check_exception()))
        {
            SWIG_exception( SWIG_ValueError, err );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_resample(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:resample",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        char * err;
        clear_exception();
        resample(arg1,arg2);
        
        if ((err = check_exception()))
        {
            SWIG_exception( SWIG_ValueError, err );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_scaleAmp__SWIG_0(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    BreakpointEnvelope *arg2 = (BreakpointEnvelope *) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:scaleAmp",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_BreakpointEnvelope,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        char * err;
        clear_exception();
        scaleAmp(arg1,arg2);
        
        if ((err = check_exception()))
        {
            SWIG_exception( SWIG_ValueError, err );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_scaleBandwidth__SWIG_0(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    BreakpointEnvelope *arg2 = (BreakpointEnvelope *) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:scaleBandwidth",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_BreakpointEnvelope,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        char * err;
        clear_exception();
        scaleBandwidth(arg1,arg2);
        
        if ((err = check_exception()))
        {
            SWIG_exception( SWIG_ValueError, err );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_scaleFrequency__SWIG_0(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    BreakpointEnvelope *arg2 = (BreakpointEnvelope *) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:scaleFrequency",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_BreakpointEnvelope,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        char * err;
        clear_exception();
        scaleFrequency(arg1,arg2);
        
        if ((err = check_exception()))
        {
            SWIG_exception( SWIG_ValueError, err );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_scaleNoiseRatio__SWIG_0(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    BreakpointEnvelope *arg2 = (BreakpointEnvelope *) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:scaleNoiseRatio",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_BreakpointEnvelope,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        char * err;
        clear_exception();
        scaleNoiseRatio(arg1,arg2);
        
        if ((err = check_exception()))
        {
            SWIG_exception( SWIG_ValueError, err );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_shiftPitch__SWIG_0(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    BreakpointEnvelope *arg2 = (BreakpointEnvelope *) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:shiftPitch",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_BreakpointEnvelope,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        char * err;
        clear_exception();
        shiftPitch(arg1,arg2);
        
        if ((err = check_exception()))
        {
            SWIG_exception( SWIG_ValueError, err );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_scaleAmp__SWIG_1(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:scaleAmp",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        char * err;
        clear_exception();
        scaleAmp(arg1,arg2);
        
        if ((err = check_exception()))
        {
            SWIG_exception( SWIG_ValueError, err );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_scaleAmp(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[3];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_PartialList, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *ptr;
                if (SWIG_ConvertPtr(argv[1], (void **) &ptr, SWIGTYPE_p_BreakpointEnvelope, 0) == -1) {
                    _v = 0;
                    PyErr_Clear();
                } else {
                    _v = 1;
                }
            }
            if (_v) {
                return _wrap_scaleAmp__SWIG_0(self,args);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_PartialList, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                _v = (PyFloat_Check(argv[1]) || PyInt_Check(argv[1]) || PyLong_Check(argv[1])) ? 1 : 0;
            }
            if (_v) {
                return _wrap_scaleAmp__SWIG_1(self,args);
            }
        }
    }
    
    PyErr_SetString(PyExc_TypeError,"No matching function for overloaded 'scaleAmp'");
    return NULL;
}


static PyObject *_wrap_scaleBandwidth__SWIG_1(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:scaleBandwidth",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        char * err;
        clear_exception();
        scaleBandwidth(arg1,arg2);
        
        if ((err = check_exception()))
        {
            SWIG_exception( SWIG_ValueError, err );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_scaleBandwidth(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[3];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_PartialList, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *ptr;
                if (SWIG_ConvertPtr(argv[1], (void **) &ptr, SWIGTYPE_p_BreakpointEnvelope, 0) == -1) {
                    _v = 0;
                    PyErr_Clear();
                } else {
                    _v = 1;
                }
            }
            if (_v) {
                return _wrap_scaleBandwidth__SWIG_0(self,args);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_PartialList, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                _v = (PyFloat_Check(argv[1]) || PyInt_Check(argv[1]) || PyLong_Check(argv[1])) ? 1 : 0;
            }
            if (_v) {
                return _wrap_scaleBandwidth__SWIG_1(self,args);
            }
        }
    }
    
    PyErr_SetString(PyExc_TypeError,"No matching function for overloaded 'scaleBandwidth'");
    return NULL;
}


static PyObject *_wrap_scaleFrequency__SWIG_1(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:scaleFrequency",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        char * err;
        clear_exception();
        scaleFrequency(arg1,arg2);
        
        if ((err = check_exception()))
        {
            SWIG_exception( SWIG_ValueError, err );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_scaleFrequency(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[3];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_PartialList, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *ptr;
                if (SWIG_ConvertPtr(argv[1], (void **) &ptr, SWIGTYPE_p_BreakpointEnvelope, 0) == -1) {
                    _v = 0;
                    PyErr_Clear();
                } else {
                    _v = 1;
                }
            }
            if (_v) {
                return _wrap_scaleFrequency__SWIG_0(self,args);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_PartialList, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                _v = (PyFloat_Check(argv[1]) || PyInt_Check(argv[1]) || PyLong_Check(argv[1])) ? 1 : 0;
            }
            if (_v) {
                return _wrap_scaleFrequency__SWIG_1(self,args);
            }
        }
    }
    
    PyErr_SetString(PyExc_TypeError,"No matching function for overloaded 'scaleFrequency'");
    return NULL;
}


static PyObject *_wrap_scaleNoiseRatio__SWIG_1(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:scaleNoiseRatio",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        char * err;
        clear_exception();
        scaleNoiseRatio(arg1,arg2);
        
        if ((err = check_exception()))
        {
            SWIG_exception( SWIG_ValueError, err );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_scaleNoiseRatio(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[3];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_PartialList, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *ptr;
                if (SWIG_ConvertPtr(argv[1], (void **) &ptr, SWIGTYPE_p_BreakpointEnvelope, 0) == -1) {
                    _v = 0;
                    PyErr_Clear();
                } else {
                    _v = 1;
                }
            }
            if (_v) {
                return _wrap_scaleNoiseRatio__SWIG_0(self,args);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_PartialList, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                _v = (PyFloat_Check(argv[1]) || PyInt_Check(argv[1]) || PyLong_Check(argv[1])) ? 1 : 0;
            }
            if (_v) {
                return _wrap_scaleNoiseRatio__SWIG_1(self,args);
            }
        }
    }
    
    PyErr_SetString(PyExc_TypeError,"No matching function for overloaded 'scaleNoiseRatio'");
    return NULL;
}


static PyObject *_wrap_shiftPitch__SWIG_1(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:shiftPitch",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        char * err;
        clear_exception();
        shiftPitch(arg1,arg2);
        
        if ((err = check_exception()))
        {
            SWIG_exception( SWIG_ValueError, err );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_shiftPitch(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[3];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_PartialList, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *ptr;
                if (SWIG_ConvertPtr(argv[1], (void **) &ptr, SWIGTYPE_p_BreakpointEnvelope, 0) == -1) {
                    _v = 0;
                    PyErr_Clear();
                } else {
                    _v = 1;
                }
            }
            if (_v) {
                return _wrap_shiftPitch__SWIG_0(self,args);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_PartialList, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                _v = (PyFloat_Check(argv[1]) || PyInt_Check(argv[1]) || PyLong_Check(argv[1])) ? 1 : 0;
            }
            if (_v) {
                return _wrap_shiftPitch__SWIG_1(self,args);
            }
        }
    }
    
    PyErr_SetString(PyExc_TypeError,"No matching function for overloaded 'shiftPitch'");
    return NULL;
}


static PyObject *_wrap_shiftTime(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:shiftTime",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        char * err;
        clear_exception();
        shiftTime(arg1,arg2);
        
        if ((err = check_exception()))
        {
            SWIG_exception( SWIG_ValueError, err );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_sift(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:sift",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        char * err;
        clear_exception();
        sift(arg1);
        
        if ((err = check_exception()))
        {
            SWIG_exception( SWIG_ValueError, err );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_sortByLabel(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:sortByLabel",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        char * err;
        clear_exception();
        sortByLabel(arg1);
        
        if ((err = check_exception()))
        {
            SWIG_exception( SWIG_ValueError, err );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_version(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    char *result;
    
    if(!PyArg_ParseTuple(args,(char *)":version")) goto fail;
    {
        char * err;
        clear_exception();
        result = (char *)version();
        
        if ((err = check_exception()))
        {
            SWIG_exception( SWIG_ValueError, err );
        }
    }
    resultobj = result ? PyString_FromString(result) : Py_BuildValue((char*)"");
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_Marker__SWIG_0(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Marker *result;
    
    if(!PyArg_ParseTuple(args,(char *)":new_Marker")) goto fail;
    {
        try
        {
            result = (Marker *)new Marker();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Marker, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_Marker__SWIG_1(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    double arg1 ;
    char *arg2 ;
    Marker *result;
    
    if(!PyArg_ParseTuple(args,(char *)"ds:new_Marker",&arg1,&arg2)) goto fail;
    {
        try
        {
            result = (Marker *)new Marker(arg1,(char const *)arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Marker, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_Marker__SWIG_2(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Marker *arg1 = 0 ;
    Marker *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:new_Marker",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Marker,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try
        {
            result = (Marker *)new Marker((Marker const &)*arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Marker, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_Marker(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[3];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if (argc == 0) {
        return _wrap_new_Marker__SWIG_0(self,args);
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_Marker, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            return _wrap_new_Marker__SWIG_2(self,args);
        }
    }
    if (argc == 2) {
        int _v;
        {
            _v = (PyFloat_Check(argv[0]) || PyInt_Check(argv[0]) || PyLong_Check(argv[0])) ? 1 : 0;
        }
        if (_v) {
            {
                _v = PyString_Check(argv[1]) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_Marker__SWIG_1(self,args);
            }
        }
    }
    
    PyErr_SetString(PyExc_TypeError,"No matching function for overloaded 'new_Marker'");
    return NULL;
}


static PyObject *_wrap_Marker_name(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Marker *arg1 = (Marker *) 0 ;
    char *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Marker_name",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Marker,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (char *)Marker_name(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = result ? PyString_FromString(result) : Py_BuildValue((char*)"");
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Marker_time(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Marker *arg1 = (Marker *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Marker_time",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Marker,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (double)(arg1)->time();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Marker_setName(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Marker *arg1 = (Marker *) 0 ;
    char *arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Os:Marker_setName",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Marker,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            (arg1)->setName((char const *)arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Marker_setTime(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Marker *arg1 = (Marker *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:Marker_setTime",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Marker,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            (arg1)->setTime(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_Marker(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Marker *arg1 = (Marker *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_Marker",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Marker,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            delete arg1;
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * Marker_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_Marker, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_new_AiffFile__SWIG_0(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    char *arg1 ;
    AiffFile *result;
    
    if(!PyArg_ParseTuple(args,(char *)"s:new_AiffFile",&arg1)) goto fail;
    {
        try
        {
            result = (AiffFile *)new AiffFile((char const *)arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AiffFile, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_AiffFile__SWIG_1(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    SampleVector *arg1 = 0 ;
    double arg2 ;
    AiffFile *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:new_AiffFile",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_SampleVector,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try
        {
            result = (AiffFile *)new AiffFile(*arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AiffFile, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_AiffFile(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    AiffFile *arg1 = (AiffFile *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_AiffFile",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_AiffFile,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            delete arg1;
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_AiffFile_sampleRate(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    AiffFile *arg1 = (AiffFile *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:AiffFile_sampleRate",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_AiffFile,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (double)((AiffFile const *)arg1)->sampleRate();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_AiffFile_midiNoteNumber(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    AiffFile *arg1 = (AiffFile *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:AiffFile_midiNoteNumber",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_AiffFile,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (double)((AiffFile const *)arg1)->midiNoteNumber();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_AiffFile_sampleFrames(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    AiffFile *arg1 = (AiffFile *) 0 ;
    unsigned long result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:AiffFile_sampleFrames",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_AiffFile,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (unsigned long)((AiffFile const *)arg1)->numFrames();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_AiffFile_addPartial(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    AiffFile *arg1 = (AiffFile *) 0 ;
    Loris::Partial *arg2 = 0 ;
    double arg3 = (double) .001 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO|d:AiffFile_addPartial",&obj0,&obj1,&arg3)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_AiffFile,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_Loris__Partial,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try
        {
            (arg1)->addPartial((Loris::Partial const &)*arg2,arg3);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_AiffFile_setMidiNoteNumber(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    AiffFile *arg1 = (AiffFile *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:AiffFile_setMidiNoteNumber",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_AiffFile,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            (arg1)->setMidiNoteNumber(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_AiffFile_write(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    AiffFile *arg1 = (AiffFile *) 0 ;
    char *arg2 ;
    unsigned int arg3 = (unsigned int) 16 ;
    PyObject * obj0 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Os|O:AiffFile_write",&obj0,&arg2,&obj2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_AiffFile,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (obj2) {
        arg3 = (unsigned int) PyInt_AsLong(obj2);
        if (PyErr_Occurred()) SWIG_fail;
    }
    {
        try
        {
            (arg1)->write((char const *)arg2,arg3);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_AiffFile__SWIG_2(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    double arg2 ;
    double arg3 = (double) .001 ;
    AiffFile *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od|d:new_AiffFile",&obj0,&arg2,&arg3)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (AiffFile *)new_AiffFile__SWIG_2(arg1,arg2,arg3);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AiffFile, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_AiffFile(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[4];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 3); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if (argc == 1) {
        int _v;
        {
            _v = PyString_Check(argv[0]) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_AiffFile__SWIG_0(self,args);
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_SampleVector, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                _v = (PyFloat_Check(argv[1]) || PyInt_Check(argv[1]) || PyLong_Check(argv[1])) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_AiffFile__SWIG_1(self,args);
            }
        }
    }
    if ((argc >= 2) && (argc <= 3)) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_PartialList, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                _v = (PyFloat_Check(argv[1]) || PyInt_Check(argv[1]) || PyLong_Check(argv[1])) ? 1 : 0;
            }
            if (_v) {
                if (argc <= 2) {
                    return _wrap_new_AiffFile__SWIG_2(self,args);
                }
                {
                    _v = (PyFloat_Check(argv[2]) || PyInt_Check(argv[2]) || PyLong_Check(argv[2])) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_new_AiffFile__SWIG_2(self,args);
                }
            }
        }
    }
    
    PyErr_SetString(PyExc_TypeError,"No matching function for overloaded 'new_AiffFile'");
    return NULL;
}


static PyObject *_wrap_AiffFile_samples(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    AiffFile *arg1 = (AiffFile *) 0 ;
    SampleVector *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:AiffFile_samples",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_AiffFile,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (SampleVector *)AiffFile_samples(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_SampleVector, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_AiffFile_channels(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    AiffFile *arg1 = (AiffFile *) 0 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:AiffFile_channels",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_AiffFile,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (int)AiffFile_channels(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_AiffFile_addPartials(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    AiffFile *arg1 = (AiffFile *) 0 ;
    PartialList *arg2 = (PartialList *) 0 ;
    double arg3 = (double) 0.001 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO|d:AiffFile_addPartials",&obj0,&obj1,&arg3)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_AiffFile,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            AiffFile_addPartials(arg1,arg2,arg3);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_AiffFile_numMarkers(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    AiffFile *arg1 = (AiffFile *) 0 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:AiffFile_numMarkers",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_AiffFile,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (int)AiffFile_numMarkers(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_AiffFile_getMarker(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    AiffFile *arg1 = (AiffFile *) 0 ;
    int arg2 ;
    Marker *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:AiffFile_getMarker",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_AiffFile,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            {
                Marker &_result_ref = AiffFile_getMarker(arg1,arg2);
                result = (Marker *) &_result_ref;
            }
            
        }
        catch ( InvalidArgument & ex )
        {
            SWIG_exception(SWIG_ValueError, ex.what() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Marker, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_AiffFile_removeMarker(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    AiffFile *arg1 = (AiffFile *) 0 ;
    int arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:AiffFile_removeMarker",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_AiffFile,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            AiffFile_removeMarker(arg1,arg2);
            
        }
        catch ( InvalidArgument & ex )
        {
            SWIG_exception(SWIG_ValueError, ex.what() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_AiffFile_addMarker(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    AiffFile *arg1 = (AiffFile *) 0 ;
    Marker arg2 ;
    Marker *argp2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:AiffFile_addMarker",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_AiffFile,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &argp2, SWIGTYPE_p_Marker,SWIG_POINTER_EXCEPTION) == -1)) SWIG_fail;
    arg2 = *argp2; 
    {
        try
        {
            AiffFile_addMarker(arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * AiffFile_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_AiffFile, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_new_Analyzer(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    double arg1 ;
    double arg2 = (double) 0. ;
    Analyzer *result;
    
    if(!PyArg_ParseTuple(args,(char *)"d|d:new_Analyzer",&arg1,&arg2)) goto fail;
    {
        try
        {
            result = (Analyzer *)new_Analyzer(arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Analyzer, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Analyzer_copy(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg1 = (Analyzer *) 0 ;
    Analyzer *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Analyzer_copy",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Analyzer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (Analyzer *)Analyzer_copy(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Analyzer, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Analyzer_analyze__SWIG_0(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg1 = (Analyzer *) 0 ;
    SampleVector *arg2 = (SampleVector *) 0 ;
    double arg3 ;
    PartialList *result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOd:Analyzer_analyze",&obj0,&obj1,&arg3)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Analyzer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_SampleVector,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (PartialList *)Analyzer_analyze__SWIG_0(arg1,(SampleVector const *)arg2,arg3);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_PartialList, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Analyzer_analyze__SWIG_1(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg1 = (Analyzer *) 0 ;
    SampleVector *arg2 = (SampleVector *) 0 ;
    double arg3 ;
    BreakpointEnvelope *arg4 = (BreakpointEnvelope *) 0 ;
    PartialList *result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj3 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOdO:Analyzer_analyze",&obj0,&obj1,&arg3,&obj3)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Analyzer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_SampleVector,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj3,(void **) &arg4, SWIGTYPE_p_BreakpointEnvelope,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (PartialList *)Analyzer_analyze__SWIG_1(arg1,(SampleVector const *)arg2,arg3,arg4);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_PartialList, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Analyzer_analyze(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[5];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 4); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_Analyzer, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *ptr;
                if (SWIG_ConvertPtr(argv[1], (void **) &ptr, SWIGTYPE_p_SampleVector, 0) == -1) {
                    _v = 0;
                    PyErr_Clear();
                } else {
                    _v = 1;
                }
            }
            if (_v) {
                {
                    _v = (PyFloat_Check(argv[2]) || PyInt_Check(argv[2]) || PyLong_Check(argv[2])) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_Analyzer_analyze__SWIG_0(self,args);
                }
            }
        }
    }
    if (argc == 4) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_Analyzer, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *ptr;
                if (SWIG_ConvertPtr(argv[1], (void **) &ptr, SWIGTYPE_p_SampleVector, 0) == -1) {
                    _v = 0;
                    PyErr_Clear();
                } else {
                    _v = 1;
                }
            }
            if (_v) {
                {
                    _v = (PyFloat_Check(argv[2]) || PyInt_Check(argv[2]) || PyLong_Check(argv[2])) ? 1 : 0;
                }
                if (_v) {
                    {
                        void *ptr;
                        if (SWIG_ConvertPtr(argv[3], (void **) &ptr, SWIGTYPE_p_BreakpointEnvelope, 0) == -1) {
                            _v = 0;
                            PyErr_Clear();
                        } else {
                            _v = 1;
                        }
                    }
                    if (_v) {
                        return _wrap_Analyzer_analyze__SWIG_1(self,args);
                    }
                }
            }
        }
    }
    
    PyErr_SetString(PyExc_TypeError,"No matching function for overloaded 'Analyzer_analyze'");
    return NULL;
}


static PyObject *_wrap_Analyzer_freqResolution(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg1 = (Analyzer *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Analyzer_freqResolution",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Analyzer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (double)((Analyzer const *)arg1)->freqResolution();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Analyzer_ampFloor(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg1 = (Analyzer *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Analyzer_ampFloor",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Analyzer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (double)((Analyzer const *)arg1)->ampFloor();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Analyzer_windowWidth(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg1 = (Analyzer *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Analyzer_windowWidth",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Analyzer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (double)((Analyzer const *)arg1)->windowWidth();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Analyzer_sidelobeLevel(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg1 = (Analyzer *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Analyzer_sidelobeLevel",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Analyzer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (double)((Analyzer const *)arg1)->sidelobeLevel();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Analyzer_freqFloor(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg1 = (Analyzer *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Analyzer_freqFloor",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Analyzer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (double)((Analyzer const *)arg1)->freqFloor();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Analyzer_hopTime(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg1 = (Analyzer *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Analyzer_hopTime",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Analyzer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (double)((Analyzer const *)arg1)->hopTime();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Analyzer_freqDrift(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg1 = (Analyzer *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Analyzer_freqDrift",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Analyzer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (double)((Analyzer const *)arg1)->freqDrift();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Analyzer_cropTime(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg1 = (Analyzer *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Analyzer_cropTime",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Analyzer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (double)((Analyzer const *)arg1)->cropTime();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Analyzer_bwRegionWidth(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg1 = (Analyzer *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Analyzer_bwRegionWidth",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Analyzer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (double)((Analyzer const *)arg1)->bwRegionWidth();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Analyzer_setFreqResolution(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg1 = (Analyzer *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:Analyzer_setFreqResolution",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Analyzer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            (arg1)->setFreqResolution(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Analyzer_setAmpFloor(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg1 = (Analyzer *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:Analyzer_setAmpFloor",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Analyzer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            (arg1)->setAmpFloor(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Analyzer_setWindowWidth(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg1 = (Analyzer *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:Analyzer_setWindowWidth",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Analyzer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            (arg1)->setWindowWidth(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Analyzer_setSidelobeLevel(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg1 = (Analyzer *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:Analyzer_setSidelobeLevel",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Analyzer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            (arg1)->setSidelobeLevel(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Analyzer_setFreqFloor(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg1 = (Analyzer *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:Analyzer_setFreqFloor",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Analyzer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            (arg1)->setFreqFloor(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Analyzer_setFreqDrift(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg1 = (Analyzer *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:Analyzer_setFreqDrift",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Analyzer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            (arg1)->setFreqDrift(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Analyzer_setHopTime(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg1 = (Analyzer *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:Analyzer_setHopTime",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Analyzer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            (arg1)->setHopTime(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Analyzer_setCropTime(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg1 = (Analyzer *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:Analyzer_setCropTime",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Analyzer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            (arg1)->setCropTime(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Analyzer_setBwRegionWidth(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg1 = (Analyzer *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:Analyzer_setBwRegionWidth",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Analyzer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            (arg1)->setBwRegionWidth(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_Analyzer(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Analyzer *arg1 = (Analyzer *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_Analyzer",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Analyzer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            delete arg1;
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * Analyzer_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_Analyzer, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_new_BreakpointEnvelope__SWIG_0(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    BreakpointEnvelope *result;
    
    if(!PyArg_ParseTuple(args,(char *)":new_BreakpointEnvelope")) goto fail;
    {
        try
        {
            result = (BreakpointEnvelope *)new BreakpointEnvelope();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_BreakpointEnvelope, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_BreakpointEnvelope__SWIG_1(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    double arg1 ;
    BreakpointEnvelope *result;
    
    if(!PyArg_ParseTuple(args,(char *)"d:new_BreakpointEnvelope",&arg1)) goto fail;
    {
        try
        {
            result = (BreakpointEnvelope *)new BreakpointEnvelope(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_BreakpointEnvelope, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_BreakpointEnvelope(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[2];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 1); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if (argc == 0) {
        return _wrap_new_BreakpointEnvelope__SWIG_0(self,args);
    }
    if (argc == 1) {
        int _v;
        {
            _v = (PyFloat_Check(argv[0]) || PyInt_Check(argv[0]) || PyLong_Check(argv[0])) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_BreakpointEnvelope__SWIG_1(self,args);
        }
    }
    
    PyErr_SetString(PyExc_TypeError,"No matching function for overloaded 'new_BreakpointEnvelope'");
    return NULL;
}


static PyObject *_wrap_delete_BreakpointEnvelope(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    BreakpointEnvelope *arg1 = (BreakpointEnvelope *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_BreakpointEnvelope",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_BreakpointEnvelope,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            delete arg1;
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_BreakpointEnvelope_copy(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    BreakpointEnvelope *arg1 = (BreakpointEnvelope *) 0 ;
    BreakpointEnvelope *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:BreakpointEnvelope_copy",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_BreakpointEnvelope,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (BreakpointEnvelope *)BreakpointEnvelope_copy(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_BreakpointEnvelope, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_BreakpointEnvelope_insertBreakpoint(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    BreakpointEnvelope *arg1 = (BreakpointEnvelope *) 0 ;
    double arg2 ;
    double arg3 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Odd:BreakpointEnvelope_insertBreakpoint",&obj0,&arg2,&arg3)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_BreakpointEnvelope,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            (arg1)->insertBreakpoint(arg2,arg3);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_BreakpointEnvelope_valueAt(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    BreakpointEnvelope *arg1 = (BreakpointEnvelope *) 0 ;
    double arg2 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:BreakpointEnvelope_valueAt",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_BreakpointEnvelope,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (double)((BreakpointEnvelope const *)arg1)->valueAt(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject * BreakpointEnvelope_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_BreakpointEnvelope, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_BreakpointEnvelopeWithValue(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    double arg1 ;
    BreakpointEnvelope *result;
    
    if(!PyArg_ParseTuple(args,(char *)"d:BreakpointEnvelopeWithValue",&arg1)) goto fail;
    {
        try
        {
            result = (BreakpointEnvelope *)BreakpointEnvelopeWithValue(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_BreakpointEnvelope, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_SampleVector(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    unsigned long arg1 = (unsigned long) 0 ;
    SampleVector *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"|O:new_SampleVector",&obj0)) goto fail;
    if (obj0) {
        arg1 = (unsigned long) PyInt_AsLong(obj0);
        if (PyErr_Occurred()) SWIG_fail;
    }
    {
        try
        {
            result = (SampleVector *)new SampleVector(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_SampleVector, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_SampleVector(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    SampleVector *arg1 = (SampleVector *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_SampleVector",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_SampleVector,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            delete arg1;
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_SampleVector_clear(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    SampleVector *arg1 = (SampleVector *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:SampleVector_clear",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_SampleVector,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            (arg1)->clear();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_SampleVector_resize(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    SampleVector *arg1 = (SampleVector *) 0 ;
    unsigned long arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:SampleVector_resize",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_SampleVector,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    arg2 = (unsigned long) PyInt_AsLong(obj1);
    if (PyErr_Occurred()) SWIG_fail;
    {
        try
        {
            (arg1)->resize(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_SampleVector_size(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    SampleVector *arg1 = (SampleVector *) 0 ;
    unsigned long result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:SampleVector_size",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_SampleVector,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (unsigned long)(arg1)->size();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_SampleVector_copy(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    SampleVector *arg1 = (SampleVector *) 0 ;
    SampleVector *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:SampleVector_copy",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_SampleVector,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (SampleVector *)SampleVector_copy(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_SampleVector, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_SampleVector_getAt(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    SampleVector *arg1 = (SampleVector *) 0 ;
    unsigned long arg2 ;
    double result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:SampleVector_getAt",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_SampleVector,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    arg2 = (unsigned long) PyInt_AsLong(obj1);
    if (PyErr_Occurred()) SWIG_fail;
    {
        try
        {
            result = (double)SampleVector_getAt(arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_SampleVector_setAt(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    SampleVector *arg1 = (SampleVector *) 0 ;
    unsigned long arg2 ;
    double arg3 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOd:SampleVector_setAt",&obj0,&obj1,&arg3)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_SampleVector,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    arg2 = (unsigned long) PyInt_AsLong(obj1);
    if (PyErr_Occurred()) SWIG_fail;
    {
        try
        {
            SampleVector_setAt(arg1,arg2,arg3);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * SampleVector_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_SampleVector, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_new_SdifFile__SWIG_0(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    char *arg1 ;
    SdifFile *result;
    
    if(!PyArg_ParseTuple(args,(char *)"s:new_SdifFile",&arg1)) goto fail;
    {
        try
        {
            result = (SdifFile *)new SdifFile((char const *)arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_SdifFile, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_SdifFile__SWIG_1(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    SdifFile *result;
    
    if(!PyArg_ParseTuple(args,(char *)":new_SdifFile")) goto fail;
    {
        try
        {
            result = (SdifFile *)new SdifFile();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_SdifFile, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_SdifFile(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    SdifFile *arg1 = (SdifFile *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_SdifFile",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_SdifFile,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            delete arg1;
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_SdifFile_write(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    SdifFile *arg1 = (SdifFile *) 0 ;
    char *arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Os:SdifFile_write",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_SdifFile,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            (arg1)->write((char const *)arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_SdifFile_write1TRC(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    SdifFile *arg1 = (SdifFile *) 0 ;
    char *arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Os:SdifFile_write1TRC",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_SdifFile,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            (arg1)->write1TRC((char const *)arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_SdifFile__SWIG_2(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    SdifFile *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:new_SdifFile",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (SdifFile *)new_SdifFile__SWIG_2(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_SdifFile, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_SdifFile(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[2];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 1); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if (argc == 0) {
        return _wrap_new_SdifFile__SWIG_1(self,args);
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_PartialList, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            return _wrap_new_SdifFile__SWIG_2(self,args);
        }
    }
    if (argc == 1) {
        int _v;
        {
            _v = PyString_Check(argv[0]) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_SdifFile__SWIG_0(self,args);
        }
    }
    
    PyErr_SetString(PyExc_TypeError,"No matching function for overloaded 'new_SdifFile'");
    return NULL;
}


static PyObject *_wrap_SdifFile_partials(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    SdifFile *arg1 = (SdifFile *) 0 ;
    PartialList *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:SdifFile_partials",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_SdifFile,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (PartialList *)SdifFile_partials(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_PartialList, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_SdifFile_addPartials(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    SdifFile *arg1 = (SdifFile *) 0 ;
    PartialList *arg2 = (PartialList *) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:SdifFile_addPartials",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_SdifFile,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            SdifFile_addPartials(arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_SdifFile_numMarkers(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    SdifFile *arg1 = (SdifFile *) 0 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:SdifFile_numMarkers",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_SdifFile,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (int)SdifFile_numMarkers(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_SdifFile_getMarker(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    SdifFile *arg1 = (SdifFile *) 0 ;
    int arg2 ;
    Marker *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:SdifFile_getMarker",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_SdifFile,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            {
                Marker &_result_ref = SdifFile_getMarker(arg1,arg2);
                result = (Marker *) &_result_ref;
            }
            
        }
        catch ( InvalidArgument & ex )
        {
            SWIG_exception(SWIG_ValueError, ex.what() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Marker, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_SdifFile_removeMarker(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    SdifFile *arg1 = (SdifFile *) 0 ;
    int arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:SdifFile_removeMarker",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_SdifFile,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            SdifFile_removeMarker(arg1,arg2);
            
        }
        catch ( InvalidArgument & ex )
        {
            SWIG_exception(SWIG_ValueError, ex.what() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_SdifFile_addMarker(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    SdifFile *arg1 = (SdifFile *) 0 ;
    Marker arg2 ;
    Marker *argp2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:SdifFile_addMarker",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_SdifFile,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &argp2, SWIGTYPE_p_Marker,SWIG_POINTER_EXCEPTION) == -1)) SWIG_fail;
    arg2 = *argp2; 
    {
        try
        {
            SdifFile_addMarker(arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * SdifFile_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_SdifFile, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_new_SpcFile__SWIG_0(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    char *arg1 ;
    SpcFile *result;
    
    if(!PyArg_ParseTuple(args,(char *)"s:new_SpcFile",&arg1)) goto fail;
    {
        try
        {
            result = (SpcFile *)new SpcFile((char const *)arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_SpcFile, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_SpcFile__SWIG_1(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    double arg1 = (double) 60 ;
    SpcFile *result;
    
    if(!PyArg_ParseTuple(args,(char *)"|d:new_SpcFile",&arg1)) goto fail;
    {
        try
        {
            result = (SpcFile *)new SpcFile(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_SpcFile, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_SpcFile(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    SpcFile *arg1 = (SpcFile *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_SpcFile",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_SpcFile,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            delete arg1;
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_SpcFile_sampleRate(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    SpcFile *arg1 = (SpcFile *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:SpcFile_sampleRate",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_SpcFile,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (double)((SpcFile const *)arg1)->sampleRate();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_SpcFile_midiNoteNumber(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    SpcFile *arg1 = (SpcFile *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:SpcFile_midiNoteNumber",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_SpcFile,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (double)((SpcFile const *)arg1)->midiNoteNumber();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_SpcFile_addPartial__SWIG_0(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    SpcFile *arg1 = (SpcFile *) 0 ;
    Loris::Partial *arg2 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:SpcFile_addPartial",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_SpcFile,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_Loris__Partial,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try
        {
            (arg1)->addPartial((Loris::Partial const &)*arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_SpcFile_addPartial__SWIG_1(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    SpcFile *arg1 = (SpcFile *) 0 ;
    Loris::Partial *arg2 = 0 ;
    int arg3 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOi:SpcFile_addPartial",&obj0,&obj1,&arg3)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_SpcFile,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_Loris__Partial,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try
        {
            (arg1)->addPartial((Loris::Partial const &)*arg2,arg3);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_SpcFile_addPartial(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[4];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 3); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_SpcFile, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *ptr;
                if (SWIG_ConvertPtr(argv[1], (void **) &ptr, SWIGTYPE_p_Loris__Partial, 0) == -1) {
                    _v = 0;
                    PyErr_Clear();
                } else {
                    _v = 1;
                }
            }
            if (_v) {
                return _wrap_SpcFile_addPartial__SWIG_0(self,args);
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_SpcFile, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *ptr;
                if (SWIG_ConvertPtr(argv[1], (void **) &ptr, SWIGTYPE_p_Loris__Partial, 0) == -1) {
                    _v = 0;
                    PyErr_Clear();
                } else {
                    _v = 1;
                }
            }
            if (_v) {
                {
                    _v = (PyInt_Check(argv[2]) || PyLong_Check(argv[2])) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_SpcFile_addPartial__SWIG_1(self,args);
                }
            }
        }
    }
    
    PyErr_SetString(PyExc_TypeError,"No matching function for overloaded 'SpcFile_addPartial'");
    return NULL;
}


static PyObject *_wrap_SpcFile_setMidiNoteNumber(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    SpcFile *arg1 = (SpcFile *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:SpcFile_setMidiNoteNumber",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_SpcFile,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            (arg1)->setMidiNoteNumber(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_SpcFile_setSampleRate(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    SpcFile *arg1 = (SpcFile *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:SpcFile_setSampleRate",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_SpcFile,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            (arg1)->setSampleRate(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_SpcFile_write(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    SpcFile *arg1 = (SpcFile *) 0 ;
    char *arg2 ;
    bool arg3 = (bool) true ;
    double arg4 = (double) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Os|Od:SpcFile_write",&obj0,&arg2,&obj2,&arg4)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_SpcFile,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (obj2) {
        arg3 = PyInt_AsLong(obj2) ? true : false;
        if (PyErr_Occurred()) SWIG_fail;
    }
    {
        try
        {
            (arg1)->write((char const *)arg2,arg3,arg4);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_SpcFile__SWIG_2(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    double arg2 = (double) 60 ;
    SpcFile *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O|d:new_SpcFile",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (SpcFile *)new_SpcFile__SWIG_2(arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_SpcFile, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_SpcFile(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[3];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if ((argc >= 0) && (argc <= 1)) {
        int _v;
        if (argc <= 0) {
            return _wrap_new_SpcFile__SWIG_1(self,args);
        }
        {
            _v = (PyFloat_Check(argv[0]) || PyInt_Check(argv[0]) || PyLong_Check(argv[0])) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_SpcFile__SWIG_1(self,args);
        }
    }
    if ((argc >= 1) && (argc <= 2)) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_PartialList, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            if (argc <= 1) {
                return _wrap_new_SpcFile__SWIG_2(self,args);
            }
            {
                _v = (PyFloat_Check(argv[1]) || PyInt_Check(argv[1]) || PyLong_Check(argv[1])) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_SpcFile__SWIG_2(self,args);
            }
        }
    }
    if (argc == 1) {
        int _v;
        {
            _v = PyString_Check(argv[0]) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_SpcFile__SWIG_0(self,args);
        }
    }
    
    PyErr_SetString(PyExc_TypeError,"No matching function for overloaded 'new_SpcFile'");
    return NULL;
}


static PyObject *_wrap_SpcFile_partials(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    SpcFile *arg1 = (SpcFile *) 0 ;
    PartialList *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:SpcFile_partials",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_SpcFile,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (PartialList *)SpcFile_partials(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_PartialList, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_SpcFile_addPartials(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    SpcFile *arg1 = (SpcFile *) 0 ;
    PartialList *arg2 = (PartialList *) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:SpcFile_addPartials",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_SpcFile,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            SpcFile_addPartials(arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_SpcFile_numMarkers(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    SpcFile *arg1 = (SpcFile *) 0 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:SpcFile_numMarkers",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_SpcFile,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (int)SpcFile_numMarkers(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_SpcFile_getMarker(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    SpcFile *arg1 = (SpcFile *) 0 ;
    int arg2 ;
    Marker *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:SpcFile_getMarker",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_SpcFile,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            {
                Marker &_result_ref = SpcFile_getMarker(arg1,arg2);
                result = (Marker *) &_result_ref;
            }
            
        }
        catch ( InvalidArgument & ex )
        {
            SWIG_exception(SWIG_ValueError, ex.what() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Marker, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_SpcFile_removeMarker(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    SpcFile *arg1 = (SpcFile *) 0 ;
    int arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:SpcFile_removeMarker",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_SpcFile,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            SpcFile_removeMarker(arg1,arg2);
            
        }
        catch ( InvalidArgument & ex )
        {
            SWIG_exception(SWIG_ValueError, ex.what() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_SpcFile_addMarker(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    SpcFile *arg1 = (SpcFile *) 0 ;
    Marker arg2 ;
    Marker *argp2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:SpcFile_addMarker",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_SpcFile,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &argp2, SWIGTYPE_p_Marker,SWIG_POINTER_EXCEPTION) == -1)) SWIG_fail;
    arg2 = *argp2; 
    {
        try
        {
            SpcFile_addMarker(arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * SpcFile_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_SpcFile, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_NewPlistIterator_atEnd(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    NewPlistIterator *arg1 = (NewPlistIterator *) 0 ;
    bool result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:NewPlistIterator_atEnd",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_NewPlistIterator,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (bool)(arg1)->atEnd();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NewPlistIterator_next(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    NewPlistIterator *arg1 = (NewPlistIterator *) 0 ;
    Partial *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:NewPlistIterator_next",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_NewPlistIterator,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        char * err;
        clear_exception();
        result = (Partial *)(arg1)->next();
        
        if ((err = check_exception()))
        {
#ifndef NO_PYTHON_EXC_STOPITER
            PyErr_SetString( PyExc_StopIteration, err );
            return NULL;
#else
            SWIG_exception( SWIG_ValueError, err );
#endif
            
            
            
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Partial, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NewPlistIterator_partial(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    NewPlistIterator *arg1 = (NewPlistIterator *) 0 ;
    Partial *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:NewPlistIterator_partial",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_NewPlistIterator,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        char * err;
        clear_exception();
        result = (Partial *)NewPlistIterator_partial(arg1);
        
        if ((err = check_exception()))
        {
            SWIG_exception( SWIG_ValueError, err );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Partial, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject * NewPlistIterator_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_NewPlistIterator, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_NewPartialIterator_atEnd(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    NewPartialIterator *arg1 = (NewPartialIterator *) 0 ;
    bool result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:NewPartialIterator_atEnd",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_NewPartialIterator,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (bool)(arg1)->atEnd();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NewPartialIterator_hasNext(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    NewPartialIterator *arg1 = (NewPartialIterator *) 0 ;
    bool result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:NewPartialIterator_hasNext",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_NewPartialIterator,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (bool)(arg1)->hasNext();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NewPartialIterator_next(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    NewPartialIterator *arg1 = (NewPartialIterator *) 0 ;
    BreakpointPosition *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:NewPartialIterator_next",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_NewPartialIterator,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        char * err;
        clear_exception();
        result = (BreakpointPosition *)(arg1)->next();
        
        if ((err = check_exception()))
        {
#ifndef NO_PYTHON_EXC_STOPITER
            PyErr_SetString( PyExc_StopIteration, err );
            return NULL;
#else
            SWIG_exception( SWIG_ValueError, err );
#endif
            
            
            
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_BreakpointPosition, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject * NewPartialIterator_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_NewPartialIterator, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_new_PartialList__SWIG_0(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *result;
    
    if(!PyArg_ParseTuple(args,(char *)":new_PartialList")) goto fail;
    {
        try
        {
            result = (PartialList *)new PartialList();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_PartialList, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_PartialList__SWIG_1(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = 0 ;
    PartialList *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:new_PartialList",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try
        {
            result = (PartialList *)new PartialList((PartialList const &)*arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_PartialList, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_PartialList(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[2];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 1); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if (argc == 0) {
        return _wrap_new_PartialList__SWIG_0(self,args);
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_PartialList, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            return _wrap_new_PartialList__SWIG_1(self,args);
        }
    }
    
    PyErr_SetString(PyExc_TypeError,"No matching function for overloaded 'new_PartialList'");
    return NULL;
}


static PyObject *_wrap_delete_PartialList(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_PartialList",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            delete arg1;
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PartialList_clear(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PartialList_clear",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            (arg1)->clear();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PartialList_size(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    unsigned long result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PartialList_size",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (unsigned long)(arg1)->size();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PartialList_timeSpan(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    double *arg2 = (double *) 0 ;
    double *arg3 = (double *) 0 ;
    double temp2 ;
    double temp3 ;
    PyObject * obj0 = 0 ;
    
    arg2 = &temp2;
    arg3 = &temp3;
    if(!PyArg_ParseTuple(args,(char *)"O:PartialList_timeSpan",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            PartialList_timeSpan(arg1,arg2,arg3);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    {
        PyObject *o = PyFloat_FromDouble((double) (*arg2));
        resultobj = t_output_helper(resultobj,o);
    }
    {
        PyObject *o = PyFloat_FromDouble((double) (*arg3));
        resultobj = t_output_helper(resultobj,o);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PartialList_iterator(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    NewPlistIterator *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PartialList_iterator",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (NewPlistIterator *)PartialList_iterator(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_NewPlistIterator, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PartialList___iter__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    NewPlistIterator *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PartialList___iter__",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (NewPlistIterator *)PartialList___iter__(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_NewPlistIterator, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PartialList_append(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    Partial *arg2 = (Partial *) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:PartialList_append",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_Partial,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            PartialList_append(arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PartialList_insert__SWIG_0(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    NewPlistIterator *arg2 = (NewPlistIterator *) 0 ;
    Partial *arg3 = (Partial *) 0 ;
    NewPlistIterator *result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOO:PartialList_insert",&obj0,&obj1,&obj2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_NewPlistIterator,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj2,(void **) &arg3, SWIGTYPE_p_Partial,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (NewPlistIterator *)PartialList_insert__SWIG_0(arg1,arg2,arg3);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_NewPlistIterator, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PartialList_erase__SWIG_0(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    Partial *arg2 = (Partial *) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:PartialList_erase",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_Partial,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        char * err;
        clear_exception();
        PartialList_erase__SWIG_0(arg1,arg2);
        
        if ((err = check_exception()))
        {
            SWIG_exception( SWIG_ValueError, err );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PartialList_splice__SWIG_0(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    PartialList *arg2 = (PartialList *) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:PartialList_splice",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            PartialList_splice__SWIG_0(arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PartialList_begin(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    PartialListIterator result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PartialList_begin",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (arg1)->begin();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    {
        PartialListIterator * resultptr;
        resultptr = new PartialListIterator((PartialListIterator &) result);
        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_PartialListIterator, 1);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PartialList_end(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    PartialListIterator result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PartialList_end",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (arg1)->end();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    {
        PartialListIterator * resultptr;
        resultptr = new PartialListIterator((PartialListIterator &) result);
        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_PartialListIterator, 1);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PartialList_insert__SWIG_1(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    PartialListIterator arg2 ;
    Partial *arg3 = 0 ;
    PartialListIterator result;
    PartialListIterator *argp2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOO:PartialList_insert",&obj0,&obj1,&obj2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &argp2, SWIGTYPE_p_PartialListIterator,SWIG_POINTER_EXCEPTION) == -1)) SWIG_fail;
    arg2 = *argp2; 
    if ((SWIG_ConvertPtr(obj2,(void **) &arg3, SWIGTYPE_p_Partial,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg3 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try
        {
            result = (arg1)->insert(arg2,(Partial const &)*arg3);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    {
        PartialListIterator * resultptr;
        resultptr = new PartialListIterator((PartialListIterator &) result);
        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_PartialListIterator, 1);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PartialList_erase__SWIG_1(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    PartialListIterator arg2 ;
    PartialListIterator *argp2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:PartialList_erase",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &argp2, SWIGTYPE_p_PartialListIterator,SWIG_POINTER_EXCEPTION) == -1)) SWIG_fail;
    arg2 = *argp2; 
    {
        char * err;
        clear_exception();
        (arg1)->erase(arg2);
        
        if ((err = check_exception()))
        {
            SWIG_exception( SWIG_ValueError, err );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PartialList_erase(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[3];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_PartialList, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *ptr;
                if (SWIG_ConvertPtr(argv[1], (void **) &ptr, SWIGTYPE_p_Partial, 0) == -1) {
                    _v = 0;
                    PyErr_Clear();
                } else {
                    _v = 1;
                }
            }
            if (_v) {
                return _wrap_PartialList_erase__SWIG_0(self,args);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_PartialList, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *ptr;
                if (SWIG_ConvertPtr(argv[1], (void **) &ptr, SWIGTYPE_p_PartialListIterator, 0) == -1) {
                    _v = 0;
                    PyErr_Clear();
                } else {
                    _v = 1;
                }
            }
            if (_v) {
                return _wrap_PartialList_erase__SWIG_1(self,args);
            }
        }
    }
    
    PyErr_SetString(PyExc_TypeError,"No matching function for overloaded 'PartialList_erase'");
    return NULL;
}


static PyObject *_wrap_PartialList_splice__SWIG_1(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    PartialListIterator arg2 ;
    PartialList *arg3 = 0 ;
    PartialListIterator *argp2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOO:PartialList_splice",&obj0,&obj1,&obj2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &argp2, SWIGTYPE_p_PartialListIterator,SWIG_POINTER_EXCEPTION) == -1)) SWIG_fail;
    arg2 = *argp2; 
    if ((SWIG_ConvertPtr(obj2,(void **) &arg3, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg3 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try
        {
            (arg1)->splice(arg2,*arg3);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PartialList_splice(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[4];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 3); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_PartialList, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *ptr;
                if (SWIG_ConvertPtr(argv[1], (void **) &ptr, SWIGTYPE_p_PartialList, 0) == -1) {
                    _v = 0;
                    PyErr_Clear();
                } else {
                    _v = 1;
                }
            }
            if (_v) {
                return _wrap_PartialList_splice__SWIG_0(self,args);
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_PartialList, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *ptr;
                if (SWIG_ConvertPtr(argv[1], (void **) &ptr, SWIGTYPE_p_PartialListIterator, 0) == -1) {
                    _v = 0;
                    PyErr_Clear();
                } else {
                    _v = 1;
                }
            }
            if (_v) {
                {
                    void *ptr;
                    if (SWIG_ConvertPtr(argv[2], (void **) &ptr, SWIGTYPE_p_PartialList, 0) == -1) {
                        _v = 0;
                        PyErr_Clear();
                    } else {
                        _v = 1;
                    }
                }
                if (_v) {
                    return _wrap_PartialList_splice__SWIG_1(self,args);
                }
            }
        }
    }
    
    PyErr_SetString(PyExc_TypeError,"No matching function for overloaded 'PartialList_splice'");
    return NULL;
}


static PyObject *_wrap_PartialList_insert__SWIG_2(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    Partial *arg2 = 0 ;
    PartialListIterator result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:PartialList_insert",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_Partial,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try
        {
            result = PartialList_insert__SWIG_2(arg1,(Partial const &)*arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    {
        PartialListIterator * resultptr;
        resultptr = new PartialListIterator((PartialListIterator &) result);
        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_PartialListIterator, 1);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PartialList_insert(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[4];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 3); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_PartialList, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *ptr;
                if (SWIG_ConvertPtr(argv[1], (void **) &ptr, SWIGTYPE_p_Partial, 0) == -1) {
                    _v = 0;
                    PyErr_Clear();
                } else {
                    _v = 1;
                }
            }
            if (_v) {
                return _wrap_PartialList_insert__SWIG_2(self,args);
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_PartialList, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *ptr;
                if (SWIG_ConvertPtr(argv[1], (void **) &ptr, SWIGTYPE_p_PartialListIterator, 0) == -1) {
                    _v = 0;
                    PyErr_Clear();
                } else {
                    _v = 1;
                }
            }
            if (_v) {
                {
                    void *ptr;
                    if (SWIG_ConvertPtr(argv[2], (void **) &ptr, SWIGTYPE_p_Partial, 0) == -1) {
                        _v = 0;
                        PyErr_Clear();
                    } else {
                        _v = 1;
                    }
                }
                if (_v) {
                    return _wrap_PartialList_insert__SWIG_1(self,args);
                }
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_PartialList, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *ptr;
                if (SWIG_ConvertPtr(argv[1], (void **) &ptr, SWIGTYPE_p_NewPlistIterator, 0) == -1) {
                    _v = 0;
                    PyErr_Clear();
                } else {
                    _v = 1;
                }
            }
            if (_v) {
                {
                    void *ptr;
                    if (SWIG_ConvertPtr(argv[2], (void **) &ptr, SWIGTYPE_p_Partial, 0) == -1) {
                        _v = 0;
                        PyErr_Clear();
                    } else {
                        _v = 1;
                    }
                }
                if (_v) {
                    return _wrap_PartialList_insert__SWIG_0(self,args);
                }
            }
        }
    }
    
    PyErr_SetString(PyExc_TypeError,"No matching function for overloaded 'PartialList_insert'");
    return NULL;
}


static PyObject *_wrap_PartialList_copy(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialList *arg1 = (PartialList *) 0 ;
    PartialList *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PartialList_copy",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialList,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (PartialList *)PartialList_copy(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_PartialList, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject * PartialList_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_PartialList, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_new_Partial__SWIG_0(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Partial *result;
    
    if(!PyArg_ParseTuple(args,(char *)":new_Partial")) goto fail;
    {
        try
        {
            result = (Partial *)new Partial();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Partial, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_Partial__SWIG_1(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Partial *arg1 = 0 ;
    Partial *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:new_Partial",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Partial,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try
        {
            result = (Partial *)new Partial((Partial const &)*arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Partial, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_Partial(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[2];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 1); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if (argc == 0) {
        return _wrap_new_Partial__SWIG_0(self,args);
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_Partial, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            return _wrap_new_Partial__SWIG_1(self,args);
        }
    }
    
    PyErr_SetString(PyExc_TypeError,"No matching function for overloaded 'new_Partial'");
    return NULL;
}


static PyObject *_wrap_delete_Partial(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Partial *arg1 = (Partial *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_Partial",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Partial,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            delete arg1;
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Partial_label(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Partial *arg1 = (Partial *) 0 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Partial_label",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Partial,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (int)(arg1)->label();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Partial_initialPhase(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Partial *arg1 = (Partial *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Partial_initialPhase",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Partial,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (double)(arg1)->initialPhase();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Partial_startTime(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Partial *arg1 = (Partial *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Partial_startTime",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Partial,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (double)(arg1)->startTime();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Partial_endTime(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Partial *arg1 = (Partial *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Partial_endTime",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Partial,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (double)(arg1)->endTime();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Partial_duration(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Partial *arg1 = (Partial *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Partial_duration",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Partial,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (double)(arg1)->duration();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Partial_numBreakpoints(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Partial *arg1 = (Partial *) 0 ;
    long result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Partial_numBreakpoints",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Partial,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (long)(arg1)->numBreakpoints();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Partial_setLabel(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Partial *arg1 = (Partial *) 0 ;
    int arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:Partial_setLabel",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Partial,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            (arg1)->setLabel(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Partial_frequencyAt(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Partial *arg1 = (Partial *) 0 ;
    double arg2 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:Partial_frequencyAt",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Partial,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (double)(arg1)->frequencyAt(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Partial_amplitudeAt(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Partial *arg1 = (Partial *) 0 ;
    double arg2 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:Partial_amplitudeAt",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Partial,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (double)(arg1)->amplitudeAt(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Partial_bandwidthAt(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Partial *arg1 = (Partial *) 0 ;
    double arg2 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:Partial_bandwidthAt",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Partial,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (double)(arg1)->bandwidthAt(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Partial_phaseAt(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Partial *arg1 = (Partial *) 0 ;
    double arg2 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:Partial_phaseAt",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Partial,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (double)(arg1)->phaseAt(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Partial_iterator(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Partial *arg1 = (Partial *) 0 ;
    NewPartialIterator *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Partial_iterator",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Partial,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (NewPartialIterator *)Partial_iterator(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_NewPartialIterator, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Partial___iter__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Partial *arg1 = (Partial *) 0 ;
    NewPartialIterator *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Partial___iter__",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Partial,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (NewPartialIterator *)Partial___iter__(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_NewPartialIterator, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Partial_erase__SWIG_0(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Partial *arg1 = (Partial *) 0 ;
    BreakpointPosition *arg2 = (BreakpointPosition *) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:Partial_erase",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Partial,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_BreakpointPosition,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            Partial_erase__SWIG_0(arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Partial_begin(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Partial *arg1 = (Partial *) 0 ;
    PartialIterator result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Partial_begin",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Partial,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (arg1)->begin();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    {
        PartialIterator * resultptr;
        resultptr = new PartialIterator((PartialIterator &) result);
        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_PartialIterator, 1);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Partial_end(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Partial *arg1 = (Partial *) 0 ;
    PartialIterator result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Partial_end",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Partial,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (arg1)->end();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    {
        PartialIterator * resultptr;
        resultptr = new PartialIterator((PartialIterator &) result);
        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_PartialIterator, 1);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Partial_erase__SWIG_1(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Partial *arg1 = (Partial *) 0 ;
    PartialIterator *arg2 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:Partial_erase",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Partial,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_PartialIterator,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try
        {
            (arg1)->erase(*arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Partial_erase(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[3];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_Partial, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *ptr;
                if (SWIG_ConvertPtr(argv[1], (void **) &ptr, SWIGTYPE_p_BreakpointPosition, 0) == -1) {
                    _v = 0;
                    PyErr_Clear();
                } else {
                    _v = 1;
                }
            }
            if (_v) {
                return _wrap_Partial_erase__SWIG_0(self,args);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_Partial, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *ptr;
                if (SWIG_ConvertPtr(argv[1], (void **) &ptr, SWIGTYPE_p_PartialIterator, 0) == -1) {
                    _v = 0;
                    PyErr_Clear();
                } else {
                    _v = 1;
                }
            }
            if (_v) {
                return _wrap_Partial_erase__SWIG_1(self,args);
            }
        }
    }
    
    PyErr_SetString(PyExc_TypeError,"No matching function for overloaded 'Partial_erase'");
    return NULL;
}


static PyObject *_wrap_Partial_insert(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Partial *arg1 = (Partial *) 0 ;
    double arg2 ;
    Breakpoint *arg3 = 0 ;
    PartialIterator result;
    PyObject * obj0 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OdO:Partial_insert",&obj0,&arg2,&obj2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Partial,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj2,(void **) &arg3, SWIGTYPE_p_Breakpoint,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg3 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try
        {
            result = (arg1)->insert(arg2,(Breakpoint const &)*arg3);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    {
        PartialIterator * resultptr;
        resultptr = new PartialIterator((PartialIterator &) result);
        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_PartialIterator, 1);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Partial_findAfter(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Partial *arg1 = (Partial *) 0 ;
    double arg2 ;
    PartialIterator result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:Partial_findAfter",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Partial,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (arg1)->findAfter(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    {
        PartialIterator * resultptr;
        resultptr = new PartialIterator((PartialIterator &) result);
        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_PartialIterator, 1);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Partial_findNearest(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Partial *arg1 = (Partial *) 0 ;
    double arg2 ;
    PartialIterator result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:Partial_findNearest",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Partial,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (arg1)->findNearest(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    {
        PartialIterator * resultptr;
        resultptr = new PartialIterator((PartialIterator &) result);
        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_PartialIterator, 1);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Partial_copy(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Partial *arg1 = (Partial *) 0 ;
    Partial *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Partial_copy",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Partial,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (Partial *)Partial_copy(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Partial, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Partial_equals(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Partial *arg1 = (Partial *) 0 ;
    Partial *arg2 = (Partial *) 0 ;
    int result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:Partial_equals",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Partial,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_Partial,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (int)Partial_equals(arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject * Partial_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_Partial, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_new_Breakpoint__SWIG_0(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    double arg1 ;
    double arg2 ;
    double arg3 ;
    double arg4 = (double) 0. ;
    Breakpoint *result;
    
    if(!PyArg_ParseTuple(args,(char *)"ddd|d:new_Breakpoint",&arg1,&arg2,&arg3,&arg4)) goto fail;
    {
        try
        {
            result = (Breakpoint *)new Breakpoint(arg1,arg2,arg3,arg4);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Breakpoint, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_Breakpoint__SWIG_1(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Breakpoint *arg1 = 0 ;
    Breakpoint *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:new_Breakpoint",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Breakpoint,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try
        {
            result = (Breakpoint *)new Breakpoint((Breakpoint const &)*arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Breakpoint, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_Breakpoint(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[5];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 4); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_Breakpoint, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            } else {
                _v = 1;
            }
        }
        if (_v) {
            return _wrap_new_Breakpoint__SWIG_1(self,args);
        }
    }
    if ((argc >= 3) && (argc <= 4)) {
        int _v;
        {
            _v = (PyFloat_Check(argv[0]) || PyInt_Check(argv[0]) || PyLong_Check(argv[0])) ? 1 : 0;
        }
        if (_v) {
            {
                _v = (PyFloat_Check(argv[1]) || PyInt_Check(argv[1]) || PyLong_Check(argv[1])) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = (PyFloat_Check(argv[2]) || PyInt_Check(argv[2]) || PyLong_Check(argv[2])) ? 1 : 0;
                }
                if (_v) {
                    if (argc <= 3) {
                        return _wrap_new_Breakpoint__SWIG_0(self,args);
                    }
                    {
                        _v = (PyFloat_Check(argv[3]) || PyInt_Check(argv[3]) || PyLong_Check(argv[3])) ? 1 : 0;
                    }
                    if (_v) {
                        return _wrap_new_Breakpoint__SWIG_0(self,args);
                    }
                }
            }
        }
    }
    
    PyErr_SetString(PyExc_TypeError,"No matching function for overloaded 'new_Breakpoint'");
    return NULL;
}


static PyObject *_wrap_delete_Breakpoint(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Breakpoint *arg1 = (Breakpoint *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_Breakpoint",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Breakpoint,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            delete arg1;
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Breakpoint_frequency(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Breakpoint *arg1 = (Breakpoint *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Breakpoint_frequency",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Breakpoint,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (double)(arg1)->frequency();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Breakpoint_amplitude(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Breakpoint *arg1 = (Breakpoint *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Breakpoint_amplitude",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Breakpoint,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (double)(arg1)->amplitude();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Breakpoint_bandwidth(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Breakpoint *arg1 = (Breakpoint *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Breakpoint_bandwidth",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Breakpoint,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (double)(arg1)->bandwidth();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Breakpoint_phase(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Breakpoint *arg1 = (Breakpoint *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Breakpoint_phase",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Breakpoint,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (double)(arg1)->phase();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Breakpoint_setFrequency(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Breakpoint *arg1 = (Breakpoint *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:Breakpoint_setFrequency",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Breakpoint,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            (arg1)->setFrequency(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Breakpoint_setAmplitude(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Breakpoint *arg1 = (Breakpoint *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:Breakpoint_setAmplitude",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Breakpoint,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            (arg1)->setAmplitude(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Breakpoint_setBandwidth(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Breakpoint *arg1 = (Breakpoint *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:Breakpoint_setBandwidth",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Breakpoint,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            (arg1)->setBandwidth(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Breakpoint_setPhase(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Breakpoint *arg1 = (Breakpoint *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:Breakpoint_setPhase",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Breakpoint,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            (arg1)->setPhase(arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Breakpoint_copy(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Breakpoint *arg1 = (Breakpoint *) 0 ;
    Breakpoint *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Breakpoint_copy",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Breakpoint,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (Breakpoint *)Breakpoint_copy(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Breakpoint, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Breakpoint_equals(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Breakpoint *arg1 = (Breakpoint *) 0 ;
    Breakpoint *arg2 = (Breakpoint *) 0 ;
    int result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:Breakpoint_equals",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Breakpoint,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_Breakpoint,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (int)Breakpoint_equals(arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject * Breakpoint_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_Breakpoint, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_BreakpointPosition_time(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    BreakpointPosition *arg1 = (BreakpointPosition *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:BreakpointPosition_time",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_BreakpointPosition,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (double)BreakpointPosition_time(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_BreakpointPosition_breakpoint(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    BreakpointPosition *arg1 = (BreakpointPosition *) 0 ;
    Breakpoint *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:BreakpointPosition_breakpoint",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_BreakpointPosition,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (Breakpoint *)BreakpointPosition_breakpoint(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Breakpoint, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_BreakpointPosition_frequency(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    BreakpointPosition *arg1 = (BreakpointPosition *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:BreakpointPosition_frequency",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_BreakpointPosition,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (double)BreakpointPosition_frequency(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_BreakpointPosition_amplitude(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    BreakpointPosition *arg1 = (BreakpointPosition *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:BreakpointPosition_amplitude",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_BreakpointPosition,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (double)BreakpointPosition_amplitude(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_BreakpointPosition_bandwidth(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    BreakpointPosition *arg1 = (BreakpointPosition *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:BreakpointPosition_bandwidth",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_BreakpointPosition,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (double)BreakpointPosition_bandwidth(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_BreakpointPosition_phase(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    BreakpointPosition *arg1 = (BreakpointPosition *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:BreakpointPosition_phase",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_BreakpointPosition,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (double)BreakpointPosition_phase(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_BreakpointPosition_setFrequency(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    BreakpointPosition *arg1 = (BreakpointPosition *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:BreakpointPosition_setFrequency",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_BreakpointPosition,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            BreakpointPosition_setFrequency(arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_BreakpointPosition_setAmplitude(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    BreakpointPosition *arg1 = (BreakpointPosition *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:BreakpointPosition_setAmplitude",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_BreakpointPosition,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            BreakpointPosition_setAmplitude(arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_BreakpointPosition_setBandwidth(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    BreakpointPosition *arg1 = (BreakpointPosition *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:BreakpointPosition_setBandwidth",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_BreakpointPosition,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            BreakpointPosition_setBandwidth(arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_BreakpointPosition_setPhase(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    BreakpointPosition *arg1 = (BreakpointPosition *) 0 ;
    double arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Od:BreakpointPosition_setPhase",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_BreakpointPosition,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            BreakpointPosition_setPhase(arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * BreakpointPosition_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_BreakpointPosition, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_PartialIterator_time(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialIterator *arg1 = (PartialIterator *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PartialIterator_time",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialIterator,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (double)((PartialIterator const *)arg1)->time();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PartialIterator_breakpoint(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialIterator *arg1 = (PartialIterator *) 0 ;
    Breakpoint *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PartialIterator_breakpoint",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialIterator,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (Breakpoint *)PartialIterator_breakpoint(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Breakpoint, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PartialIterator_copy(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialIterator *arg1 = (PartialIterator *) 0 ;
    PartialIterator *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PartialIterator_copy",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialIterator,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (PartialIterator *)PartialIterator_copy(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_PartialIterator, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PartialIterator_next(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialIterator *arg1 = (PartialIterator *) 0 ;
    PartialIterator *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PartialIterator_next",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialIterator,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        char * err;
        clear_exception();
        result = (PartialIterator *)PartialIterator_next(arg1);
        
        if ((err = check_exception()))
        {
#ifndef NO_PYTHON_EXC_STOPITER
            PyErr_SetString( PyExc_StopIteration, err );
            return NULL;
#else
            SWIG_exception( SWIG_ValueError, err );
#endif
            
            
            
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_PartialIterator, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PartialIterator_prev(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialIterator *arg1 = (PartialIterator *) 0 ;
    PartialIterator *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PartialIterator_prev",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialIterator,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (PartialIterator *)PartialIterator_prev(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_PartialIterator, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PartialIterator_equals(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialIterator *arg1 = (PartialIterator *) 0 ;
    PartialIterator *arg2 = (PartialIterator *) 0 ;
    int result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:PartialIterator_equals",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialIterator,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_PartialIterator,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (int)PartialIterator_equals(arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PartialIterator_isInRange(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialIterator *arg1 = (PartialIterator *) 0 ;
    PartialIterator *arg2 = (PartialIterator *) 0 ;
    PartialIterator *arg3 = (PartialIterator *) 0 ;
    int result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOO:PartialIterator_isInRange",&obj0,&obj1,&obj2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialIterator,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_PartialIterator,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj2,(void **) &arg3, SWIGTYPE_p_PartialIterator,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (int)PartialIterator_isInRange(arg1,(PartialIterator const *)arg2,(PartialIterator const *)arg3);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_PartialIterator(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialIterator *result;
    
    if(!PyArg_ParseTuple(args,(char *)":new_PartialIterator")) goto fail;
    {
        try
        {
            result = (PartialIterator *)new PartialIterator();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_PartialIterator, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_PartialIterator(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialIterator *arg1 = (PartialIterator *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_PartialIterator",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialIterator,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            delete arg1;
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * PartialIterator_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_PartialIterator, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_PartialListIterator_copy(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialListIterator *arg1 = (PartialListIterator *) 0 ;
    PartialListIterator *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PartialListIterator_copy",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialListIterator,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (PartialListIterator *)PartialListIterator_copy(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_PartialListIterator, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PartialListIterator_next(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialListIterator *arg1 = (PartialListIterator *) 0 ;
    PartialListIterator *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PartialListIterator_next",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialListIterator,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        char * err;
        clear_exception();
        result = (PartialListIterator *)PartialListIterator_next(arg1);
        
        if ((err = check_exception()))
        {
#ifndef NO_PYTHON_EXC_STOPITER
            PyErr_SetString( PyExc_StopIteration, err );
            return NULL;
#else
            SWIG_exception( SWIG_ValueError, err );
#endif
            
            
            
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_PartialListIterator, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PartialListIterator_prev(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialListIterator *arg1 = (PartialListIterator *) 0 ;
    PartialListIterator *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PartialListIterator_prev",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialListIterator,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (PartialListIterator *)PartialListIterator_prev(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_PartialListIterator, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PartialListIterator_partial(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialListIterator *arg1 = (PartialListIterator *) 0 ;
    Partial *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PartialListIterator_partial",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialListIterator,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (Partial *)PartialListIterator_partial(arg1);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Partial, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PartialListIterator_equals(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialListIterator *arg1 = (PartialListIterator *) 0 ;
    PartialListIterator *arg2 = (PartialListIterator *) 0 ;
    int result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:PartialListIterator_equals",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialListIterator,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_PartialListIterator,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (int)PartialListIterator_equals(arg1,arg2);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PartialListIterator_isInRange(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialListIterator *arg1 = (PartialListIterator *) 0 ;
    PartialListIterator *arg2 = (PartialListIterator *) 0 ;
    PartialListIterator *arg3 = (PartialListIterator *) 0 ;
    int result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOO:PartialListIterator_isInRange",&obj0,&obj1,&obj2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialListIterator,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_PartialListIterator,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj2,(void **) &arg3, SWIGTYPE_p_PartialListIterator,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            result = (int)PartialListIterator_isInRange(arg1,(PartialListIterator const *)arg2,(PartialListIterator const *)arg3);
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_PartialListIterator(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialListIterator *result;
    
    if(!PyArg_ParseTuple(args,(char *)":new_PartialListIterator")) goto fail;
    {
        try
        {
            result = (PartialListIterator *)new PartialListIterator();
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_PartialListIterator, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_PartialListIterator(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PartialListIterator *arg1 = (PartialListIterator *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_PartialListIterator",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PartialListIterator,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try
        {
            delete arg1;
            
        }
        catch( Loris::Exception & ex ) 
        {
            //	catch Loris::Exceptions:
            std::string s("Loris exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
        catch( std::exception & ex ) 
        {
            //	catch std::exceptions:
            std::string s("std C++ exception: " );
            s.append( ex.what() );
            SWIG_exception( SWIG_UnknownError, (char *) s.c_str() );
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * PartialListIterator_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_PartialListIterator, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyMethodDef SwigMethods[] = {
	 { (char *)"channelize", _wrap_channelize, METH_VARARGS },
	 { (char *)"createFreqReference", _wrap_createFreqReference, METH_VARARGS },
	 { (char *)"dilate", _wrap_dilate, METH_VARARGS },
	 { (char *)"distill", _wrap_distill, METH_VARARGS },
	 { (char *)"exportAiff", _wrap_exportAiff, METH_VARARGS },
	 { (char *)"exportSdif", _wrap_exportSdif, METH_VARARGS },
	 { (char *)"exportSpc", _wrap_exportSpc, METH_VARARGS },
	 { (char *)"importSdif", _wrap_importSdif, METH_VARARGS },
	 { (char *)"importSpc", _wrap_importSpc, METH_VARARGS },
	 { (char *)"morph", _wrap_morph, METH_VARARGS },
	 { (char *)"synthesize", _wrap_synthesize, METH_VARARGS },
	 { (char *)"crop", _wrap_crop, METH_VARARGS },
	 { (char *)"copyLabeled", _wrap_copyLabeled, METH_VARARGS },
	 { (char *)"extractLabeled", _wrap_extractLabeled, METH_VARARGS },
	 { (char *)"removeLabeled", _wrap_removeLabeled, METH_VARARGS },
	 { (char *)"resample", _wrap_resample, METH_VARARGS },
	 { (char *)"scaleAmp", _wrap_scaleAmp, METH_VARARGS },
	 { (char *)"scaleBandwidth", _wrap_scaleBandwidth, METH_VARARGS },
	 { (char *)"scaleFrequency", _wrap_scaleFrequency, METH_VARARGS },
	 { (char *)"scaleNoiseRatio", _wrap_scaleNoiseRatio, METH_VARARGS },
	 { (char *)"shiftPitch", _wrap_shiftPitch, METH_VARARGS },
	 { (char *)"shiftTime", _wrap_shiftTime, METH_VARARGS },
	 { (char *)"sift", _wrap_sift, METH_VARARGS },
	 { (char *)"sortByLabel", _wrap_sortByLabel, METH_VARARGS },
	 { (char *)"version", _wrap_version, METH_VARARGS },
	 { (char *)"new_Marker", _wrap_new_Marker, METH_VARARGS },
	 { (char *)"Marker_name", _wrap_Marker_name, METH_VARARGS },
	 { (char *)"Marker_time", _wrap_Marker_time, METH_VARARGS },
	 { (char *)"Marker_setName", _wrap_Marker_setName, METH_VARARGS },
	 { (char *)"Marker_setTime", _wrap_Marker_setTime, METH_VARARGS },
	 { (char *)"delete_Marker", _wrap_delete_Marker, METH_VARARGS },
	 { (char *)"Marker_swigregister", Marker_swigregister, METH_VARARGS },
	 { (char *)"delete_AiffFile", _wrap_delete_AiffFile, METH_VARARGS },
	 { (char *)"AiffFile_sampleRate", _wrap_AiffFile_sampleRate, METH_VARARGS },
	 { (char *)"AiffFile_midiNoteNumber", _wrap_AiffFile_midiNoteNumber, METH_VARARGS },
	 { (char *)"AiffFile_sampleFrames", _wrap_AiffFile_sampleFrames, METH_VARARGS },
	 { (char *)"AiffFile_addPartial", _wrap_AiffFile_addPartial, METH_VARARGS },
	 { (char *)"AiffFile_setMidiNoteNumber", _wrap_AiffFile_setMidiNoteNumber, METH_VARARGS },
	 { (char *)"AiffFile_write", _wrap_AiffFile_write, METH_VARARGS },
	 { (char *)"new_AiffFile", _wrap_new_AiffFile, METH_VARARGS },
	 { (char *)"AiffFile_samples", _wrap_AiffFile_samples, METH_VARARGS },
	 { (char *)"AiffFile_channels", _wrap_AiffFile_channels, METH_VARARGS },
	 { (char *)"AiffFile_addPartials", _wrap_AiffFile_addPartials, METH_VARARGS },
	 { (char *)"AiffFile_numMarkers", _wrap_AiffFile_numMarkers, METH_VARARGS },
	 { (char *)"AiffFile_getMarker", _wrap_AiffFile_getMarker, METH_VARARGS },
	 { (char *)"AiffFile_removeMarker", _wrap_AiffFile_removeMarker, METH_VARARGS },
	 { (char *)"AiffFile_addMarker", _wrap_AiffFile_addMarker, METH_VARARGS },
	 { (char *)"AiffFile_swigregister", AiffFile_swigregister, METH_VARARGS },
	 { (char *)"new_Analyzer", _wrap_new_Analyzer, METH_VARARGS },
	 { (char *)"Analyzer_copy", _wrap_Analyzer_copy, METH_VARARGS },
	 { (char *)"Analyzer_analyze", _wrap_Analyzer_analyze, METH_VARARGS },
	 { (char *)"Analyzer_freqResolution", _wrap_Analyzer_freqResolution, METH_VARARGS },
	 { (char *)"Analyzer_ampFloor", _wrap_Analyzer_ampFloor, METH_VARARGS },
	 { (char *)"Analyzer_windowWidth", _wrap_Analyzer_windowWidth, METH_VARARGS },
	 { (char *)"Analyzer_sidelobeLevel", _wrap_Analyzer_sidelobeLevel, METH_VARARGS },
	 { (char *)"Analyzer_freqFloor", _wrap_Analyzer_freqFloor, METH_VARARGS },
	 { (char *)"Analyzer_hopTime", _wrap_Analyzer_hopTime, METH_VARARGS },
	 { (char *)"Analyzer_freqDrift", _wrap_Analyzer_freqDrift, METH_VARARGS },
	 { (char *)"Analyzer_cropTime", _wrap_Analyzer_cropTime, METH_VARARGS },
	 { (char *)"Analyzer_bwRegionWidth", _wrap_Analyzer_bwRegionWidth, METH_VARARGS },
	 { (char *)"Analyzer_setFreqResolution", _wrap_Analyzer_setFreqResolution, METH_VARARGS },
	 { (char *)"Analyzer_setAmpFloor", _wrap_Analyzer_setAmpFloor, METH_VARARGS },
	 { (char *)"Analyzer_setWindowWidth", _wrap_Analyzer_setWindowWidth, METH_VARARGS },
	 { (char *)"Analyzer_setSidelobeLevel", _wrap_Analyzer_setSidelobeLevel, METH_VARARGS },
	 { (char *)"Analyzer_setFreqFloor", _wrap_Analyzer_setFreqFloor, METH_VARARGS },
	 { (char *)"Analyzer_setFreqDrift", _wrap_Analyzer_setFreqDrift, METH_VARARGS },
	 { (char *)"Analyzer_setHopTime", _wrap_Analyzer_setHopTime, METH_VARARGS },
	 { (char *)"Analyzer_setCropTime", _wrap_Analyzer_setCropTime, METH_VARARGS },
	 { (char *)"Analyzer_setBwRegionWidth", _wrap_Analyzer_setBwRegionWidth, METH_VARARGS },
	 { (char *)"delete_Analyzer", _wrap_delete_Analyzer, METH_VARARGS },
	 { (char *)"Analyzer_swigregister", Analyzer_swigregister, METH_VARARGS },
	 { (char *)"new_BreakpointEnvelope", _wrap_new_BreakpointEnvelope, METH_VARARGS },
	 { (char *)"delete_BreakpointEnvelope", _wrap_delete_BreakpointEnvelope, METH_VARARGS },
	 { (char *)"BreakpointEnvelope_copy", _wrap_BreakpointEnvelope_copy, METH_VARARGS },
	 { (char *)"BreakpointEnvelope_insertBreakpoint", _wrap_BreakpointEnvelope_insertBreakpoint, METH_VARARGS },
	 { (char *)"BreakpointEnvelope_valueAt", _wrap_BreakpointEnvelope_valueAt, METH_VARARGS },
	 { (char *)"BreakpointEnvelope_swigregister", BreakpointEnvelope_swigregister, METH_VARARGS },
	 { (char *)"BreakpointEnvelopeWithValue", _wrap_BreakpointEnvelopeWithValue, METH_VARARGS },
	 { (char *)"new_SampleVector", _wrap_new_SampleVector, METH_VARARGS },
	 { (char *)"delete_SampleVector", _wrap_delete_SampleVector, METH_VARARGS },
	 { (char *)"SampleVector_clear", _wrap_SampleVector_clear, METH_VARARGS },
	 { (char *)"SampleVector_resize", _wrap_SampleVector_resize, METH_VARARGS },
	 { (char *)"SampleVector_size", _wrap_SampleVector_size, METH_VARARGS },
	 { (char *)"SampleVector_copy", _wrap_SampleVector_copy, METH_VARARGS },
	 { (char *)"SampleVector_getAt", _wrap_SampleVector_getAt, METH_VARARGS },
	 { (char *)"SampleVector_setAt", _wrap_SampleVector_setAt, METH_VARARGS },
	 { (char *)"SampleVector_swigregister", SampleVector_swigregister, METH_VARARGS },
	 { (char *)"delete_SdifFile", _wrap_delete_SdifFile, METH_VARARGS },
	 { (char *)"SdifFile_write", _wrap_SdifFile_write, METH_VARARGS },
	 { (char *)"SdifFile_write1TRC", _wrap_SdifFile_write1TRC, METH_VARARGS },
	 { (char *)"new_SdifFile", _wrap_new_SdifFile, METH_VARARGS },
	 { (char *)"SdifFile_partials", _wrap_SdifFile_partials, METH_VARARGS },
	 { (char *)"SdifFile_addPartials", _wrap_SdifFile_addPartials, METH_VARARGS },
	 { (char *)"SdifFile_numMarkers", _wrap_SdifFile_numMarkers, METH_VARARGS },
	 { (char *)"SdifFile_getMarker", _wrap_SdifFile_getMarker, METH_VARARGS },
	 { (char *)"SdifFile_removeMarker", _wrap_SdifFile_removeMarker, METH_VARARGS },
	 { (char *)"SdifFile_addMarker", _wrap_SdifFile_addMarker, METH_VARARGS },
	 { (char *)"SdifFile_swigregister", SdifFile_swigregister, METH_VARARGS },
	 { (char *)"delete_SpcFile", _wrap_delete_SpcFile, METH_VARARGS },
	 { (char *)"SpcFile_sampleRate", _wrap_SpcFile_sampleRate, METH_VARARGS },
	 { (char *)"SpcFile_midiNoteNumber", _wrap_SpcFile_midiNoteNumber, METH_VARARGS },
	 { (char *)"SpcFile_addPartial", _wrap_SpcFile_addPartial, METH_VARARGS },
	 { (char *)"SpcFile_setMidiNoteNumber", _wrap_SpcFile_setMidiNoteNumber, METH_VARARGS },
	 { (char *)"SpcFile_setSampleRate", _wrap_SpcFile_setSampleRate, METH_VARARGS },
	 { (char *)"SpcFile_write", _wrap_SpcFile_write, METH_VARARGS },
	 { (char *)"new_SpcFile", _wrap_new_SpcFile, METH_VARARGS },
	 { (char *)"SpcFile_partials", _wrap_SpcFile_partials, METH_VARARGS },
	 { (char *)"SpcFile_addPartials", _wrap_SpcFile_addPartials, METH_VARARGS },
	 { (char *)"SpcFile_numMarkers", _wrap_SpcFile_numMarkers, METH_VARARGS },
	 { (char *)"SpcFile_getMarker", _wrap_SpcFile_getMarker, METH_VARARGS },
	 { (char *)"SpcFile_removeMarker", _wrap_SpcFile_removeMarker, METH_VARARGS },
	 { (char *)"SpcFile_addMarker", _wrap_SpcFile_addMarker, METH_VARARGS },
	 { (char *)"SpcFile_swigregister", SpcFile_swigregister, METH_VARARGS },
	 { (char *)"NewPlistIterator_atEnd", _wrap_NewPlistIterator_atEnd, METH_VARARGS },
	 { (char *)"NewPlistIterator_next", _wrap_NewPlistIterator_next, METH_VARARGS },
	 { (char *)"NewPlistIterator_partial", _wrap_NewPlistIterator_partial, METH_VARARGS },
	 { (char *)"NewPlistIterator_swigregister", NewPlistIterator_swigregister, METH_VARARGS },
	 { (char *)"NewPartialIterator_atEnd", _wrap_NewPartialIterator_atEnd, METH_VARARGS },
	 { (char *)"NewPartialIterator_hasNext", _wrap_NewPartialIterator_hasNext, METH_VARARGS },
	 { (char *)"NewPartialIterator_next", _wrap_NewPartialIterator_next, METH_VARARGS },
	 { (char *)"NewPartialIterator_swigregister", NewPartialIterator_swigregister, METH_VARARGS },
	 { (char *)"new_PartialList", _wrap_new_PartialList, METH_VARARGS },
	 { (char *)"delete_PartialList", _wrap_delete_PartialList, METH_VARARGS },
	 { (char *)"PartialList_clear", _wrap_PartialList_clear, METH_VARARGS },
	 { (char *)"PartialList_size", _wrap_PartialList_size, METH_VARARGS },
	 { (char *)"PartialList_timeSpan", _wrap_PartialList_timeSpan, METH_VARARGS },
	 { (char *)"PartialList_iterator", _wrap_PartialList_iterator, METH_VARARGS },
	 { (char *)"PartialList___iter__", _wrap_PartialList___iter__, METH_VARARGS },
	 { (char *)"PartialList_append", _wrap_PartialList_append, METH_VARARGS },
	 { (char *)"PartialList_begin", _wrap_PartialList_begin, METH_VARARGS },
	 { (char *)"PartialList_end", _wrap_PartialList_end, METH_VARARGS },
	 { (char *)"PartialList_erase", _wrap_PartialList_erase, METH_VARARGS },
	 { (char *)"PartialList_splice", _wrap_PartialList_splice, METH_VARARGS },
	 { (char *)"PartialList_insert", _wrap_PartialList_insert, METH_VARARGS },
	 { (char *)"PartialList_copy", _wrap_PartialList_copy, METH_VARARGS },
	 { (char *)"PartialList_swigregister", PartialList_swigregister, METH_VARARGS },
	 { (char *)"new_Partial", _wrap_new_Partial, METH_VARARGS },
	 { (char *)"delete_Partial", _wrap_delete_Partial, METH_VARARGS },
	 { (char *)"Partial_label", _wrap_Partial_label, METH_VARARGS },
	 { (char *)"Partial_initialPhase", _wrap_Partial_initialPhase, METH_VARARGS },
	 { (char *)"Partial_startTime", _wrap_Partial_startTime, METH_VARARGS },
	 { (char *)"Partial_endTime", _wrap_Partial_endTime, METH_VARARGS },
	 { (char *)"Partial_duration", _wrap_Partial_duration, METH_VARARGS },
	 { (char *)"Partial_numBreakpoints", _wrap_Partial_numBreakpoints, METH_VARARGS },
	 { (char *)"Partial_setLabel", _wrap_Partial_setLabel, METH_VARARGS },
	 { (char *)"Partial_frequencyAt", _wrap_Partial_frequencyAt, METH_VARARGS },
	 { (char *)"Partial_amplitudeAt", _wrap_Partial_amplitudeAt, METH_VARARGS },
	 { (char *)"Partial_bandwidthAt", _wrap_Partial_bandwidthAt, METH_VARARGS },
	 { (char *)"Partial_phaseAt", _wrap_Partial_phaseAt, METH_VARARGS },
	 { (char *)"Partial_iterator", _wrap_Partial_iterator, METH_VARARGS },
	 { (char *)"Partial___iter__", _wrap_Partial___iter__, METH_VARARGS },
	 { (char *)"Partial_begin", _wrap_Partial_begin, METH_VARARGS },
	 { (char *)"Partial_end", _wrap_Partial_end, METH_VARARGS },
	 { (char *)"Partial_erase", _wrap_Partial_erase, METH_VARARGS },
	 { (char *)"Partial_insert", _wrap_Partial_insert, METH_VARARGS },
	 { (char *)"Partial_findAfter", _wrap_Partial_findAfter, METH_VARARGS },
	 { (char *)"Partial_findNearest", _wrap_Partial_findNearest, METH_VARARGS },
	 { (char *)"Partial_copy", _wrap_Partial_copy, METH_VARARGS },
	 { (char *)"Partial_equals", _wrap_Partial_equals, METH_VARARGS },
	 { (char *)"Partial_swigregister", Partial_swigregister, METH_VARARGS },
	 { (char *)"new_Breakpoint", _wrap_new_Breakpoint, METH_VARARGS },
	 { (char *)"delete_Breakpoint", _wrap_delete_Breakpoint, METH_VARARGS },
	 { (char *)"Breakpoint_frequency", _wrap_Breakpoint_frequency, METH_VARARGS },
	 { (char *)"Breakpoint_amplitude", _wrap_Breakpoint_amplitude, METH_VARARGS },
	 { (char *)"Breakpoint_bandwidth", _wrap_Breakpoint_bandwidth, METH_VARARGS },
	 { (char *)"Breakpoint_phase", _wrap_Breakpoint_phase, METH_VARARGS },
	 { (char *)"Breakpoint_setFrequency", _wrap_Breakpoint_setFrequency, METH_VARARGS },
	 { (char *)"Breakpoint_setAmplitude", _wrap_Breakpoint_setAmplitude, METH_VARARGS },
	 { (char *)"Breakpoint_setBandwidth", _wrap_Breakpoint_setBandwidth, METH_VARARGS },
	 { (char *)"Breakpoint_setPhase", _wrap_Breakpoint_setPhase, METH_VARARGS },
	 { (char *)"Breakpoint_copy", _wrap_Breakpoint_copy, METH_VARARGS },
	 { (char *)"Breakpoint_equals", _wrap_Breakpoint_equals, METH_VARARGS },
	 { (char *)"Breakpoint_swigregister", Breakpoint_swigregister, METH_VARARGS },
	 { (char *)"BreakpointPosition_time", _wrap_BreakpointPosition_time, METH_VARARGS },
	 { (char *)"BreakpointPosition_breakpoint", _wrap_BreakpointPosition_breakpoint, METH_VARARGS },
	 { (char *)"BreakpointPosition_frequency", _wrap_BreakpointPosition_frequency, METH_VARARGS },
	 { (char *)"BreakpointPosition_amplitude", _wrap_BreakpointPosition_amplitude, METH_VARARGS },
	 { (char *)"BreakpointPosition_bandwidth", _wrap_BreakpointPosition_bandwidth, METH_VARARGS },
	 { (char *)"BreakpointPosition_phase", _wrap_BreakpointPosition_phase, METH_VARARGS },
	 { (char *)"BreakpointPosition_setFrequency", _wrap_BreakpointPosition_setFrequency, METH_VARARGS },
	 { (char *)"BreakpointPosition_setAmplitude", _wrap_BreakpointPosition_setAmplitude, METH_VARARGS },
	 { (char *)"BreakpointPosition_setBandwidth", _wrap_BreakpointPosition_setBandwidth, METH_VARARGS },
	 { (char *)"BreakpointPosition_setPhase", _wrap_BreakpointPosition_setPhase, METH_VARARGS },
	 { (char *)"BreakpointPosition_swigregister", BreakpointPosition_swigregister, METH_VARARGS },
	 { (char *)"PartialIterator_time", _wrap_PartialIterator_time, METH_VARARGS },
	 { (char *)"PartialIterator_breakpoint", _wrap_PartialIterator_breakpoint, METH_VARARGS },
	 { (char *)"PartialIterator_copy", _wrap_PartialIterator_copy, METH_VARARGS },
	 { (char *)"PartialIterator_next", _wrap_PartialIterator_next, METH_VARARGS },
	 { (char *)"PartialIterator_prev", _wrap_PartialIterator_prev, METH_VARARGS },
	 { (char *)"PartialIterator_equals", _wrap_PartialIterator_equals, METH_VARARGS },
	 { (char *)"PartialIterator_isInRange", _wrap_PartialIterator_isInRange, METH_VARARGS },
	 { (char *)"new_PartialIterator", _wrap_new_PartialIterator, METH_VARARGS },
	 { (char *)"delete_PartialIterator", _wrap_delete_PartialIterator, METH_VARARGS },
	 { (char *)"PartialIterator_swigregister", PartialIterator_swigregister, METH_VARARGS },
	 { (char *)"PartialListIterator_copy", _wrap_PartialListIterator_copy, METH_VARARGS },
	 { (char *)"PartialListIterator_next", _wrap_PartialListIterator_next, METH_VARARGS },
	 { (char *)"PartialListIterator_prev", _wrap_PartialListIterator_prev, METH_VARARGS },
	 { (char *)"PartialListIterator_partial", _wrap_PartialListIterator_partial, METH_VARARGS },
	 { (char *)"PartialListIterator_equals", _wrap_PartialListIterator_equals, METH_VARARGS },
	 { (char *)"PartialListIterator_isInRange", _wrap_PartialListIterator_isInRange, METH_VARARGS },
	 { (char *)"new_PartialListIterator", _wrap_new_PartialListIterator, METH_VARARGS },
	 { (char *)"delete_PartialListIterator", _wrap_delete_PartialListIterator, METH_VARARGS },
	 { (char *)"PartialListIterator_swigregister", PartialListIterator_swigregister, METH_VARARGS },
	 { NULL, NULL }
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */

static swig_type_info _swigt__p_PartialList[] = {{"_p_PartialList", 0, "PartialList *", 0},{"_p_PartialList"},{0}};
static swig_type_info _swigt__p_SpcFile[] = {{"_p_SpcFile", 0, "SpcFile *", 0},{"_p_SpcFile"},{0}};
static swig_type_info _swigt__p_Breakpoint[] = {{"_p_Breakpoint", 0, "Breakpoint *", 0},{"_p_Breakpoint"},{0}};
static swig_type_info _swigt__p_Analyzer[] = {{"_p_Analyzer", 0, "Analyzer *", 0},{"_p_Analyzer"},{0}};
static swig_type_info _swigt__p_double[] = {{"_p_double", 0, "double *", 0},{"_p_double"},{0}};
static swig_type_info _swigt__p_Partial[] = {{"_p_Partial", 0, "Partial *", 0},{"_p_Partial"},{0}};
static swig_type_info _swigt__p_Loris__Partial[] = {{"_p_Loris__Partial", 0, "Loris::Partial *", 0},{"_p_Loris__Partial"},{0}};
static swig_type_info _swigt__p_vectorTdouble_t[] = {{"_p_vectorTdouble_t", 0, "vector<double > *", 0},{"_p_vectorTdouble_t"},{0}};
static swig_type_info _swigt__p_BreakpointEnvelope[] = {{"_p_BreakpointEnvelope", 0, "BreakpointEnvelope *", 0},{"_p_BreakpointEnvelope"},{0}};
static swig_type_info _swigt__p_BreakpointPosition[] = {{"_p_BreakpointPosition", 0, "BreakpointPosition *", 0},{"_p_BreakpointPosition"},{0}};
static swig_type_info _swigt__p_AiffFile[] = {{"_p_AiffFile", 0, "AiffFile *", 0},{"_p_AiffFile"},{0}};
static swig_type_info _swigt__p_SampleVector[] = {{"_p_SampleVector", 0, "SampleVector *", 0},{"_p_SampleVector"},{0}};
static swig_type_info _swigt__p_SdifFile[] = {{"_p_SdifFile", 0, "SdifFile *", 0},{"_p_SdifFile"},{0}};
static swig_type_info _swigt__p_NewPartialIterator[] = {{"_p_NewPartialIterator", 0, "NewPartialIterator *", 0},{"_p_NewPartialIterator"},{0}};
static swig_type_info _swigt__p_NewPlistIterator[] = {{"_p_NewPlistIterator", 0, "NewPlistIterator *", 0},{"_p_NewPlistIterator"},{0}};
static swig_type_info _swigt__p_Marker[] = {{"_p_Marker", 0, "Marker *", 0},{"_p_Marker"},{0}};
static swig_type_info _swigt__p_PartialListIterator[] = {{"_p_PartialListIterator", 0, "PartialListIterator *", 0},{"_p_PartialListIterator"},{0}};
static swig_type_info _swigt__p_PartialIterator[] = {{"_p_PartialIterator", 0, "PartialIterator *", 0},{"_p_PartialIterator"},{0}};

static swig_type_info *swig_types_initial[] = {
_swigt__p_PartialList, 
_swigt__p_SpcFile, 
_swigt__p_Breakpoint, 
_swigt__p_Analyzer, 
_swigt__p_double, 
_swigt__p_Partial, 
_swigt__p_Loris__Partial, 
_swigt__p_vectorTdouble_t, 
_swigt__p_BreakpointEnvelope, 
_swigt__p_BreakpointPosition, 
_swigt__p_AiffFile, 
_swigt__p_SampleVector, 
_swigt__p_SdifFile, 
_swigt__p_NewPartialIterator, 
_swigt__p_NewPlistIterator, 
_swigt__p_Marker, 
_swigt__p_PartialListIterator, 
_swigt__p_PartialIterator, 
0
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */

static swig_const_info swig_const_table[] = {
{0}};

#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C"
#endif
SWIGEXPORT(void) SWIG_init(void) {
    static PyObject *SWIG_globals = 0; 
    static int       typeinit = 0;
    PyObject *m, *d;
    int       i;
    if (!SWIG_globals) SWIG_globals = SWIG_newvarlink();
    m = Py_InitModule((char *) SWIG_name, SwigMethods);
    d = PyModule_GetDict(m);
    
    if (!typeinit) {
        for (i = 0; swig_types_initial[i]; i++) {
            swig_types[i] = SWIG_TypeRegister(swig_types_initial[i]);
        }
        typeinit = 1;
    }
    SWIG_InstallConstants(d,swig_const_table);
    
    
    Loris::setNotifier( printf_notifier );
    Loris::setExceptionHandler( throw_exception );
    
}

